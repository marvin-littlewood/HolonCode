
  0.002 Installiert 

mark insert 1.0 mark current 1.0 text {Von Holon importiert Rev. 2.165 
} 1.0 text {RunCommand = Run TkCon 
} 2.0 text { } 3.0

Von Holon importiert Rev. 2.165 
RunCommand = Run TkCon




  0.003 Objecttype => Class 

mark insert 1.0 mark current 1.0 text {GetItem geflickt.
} 1.0 text {Objecttype => Class - das Konzept bereinigen. - deutlich eleganter. Noch eleganter wäre :
} 2.0 text {
} 3.0 text class\ variable\ \{\n 4.0 text {	set   {...}
} 5.0 text {	get   {...}
} 6.0 text \}\ \n 7.0 mark tk::anchor.work.page.panes.t.text 8.0 text {
} 8.0 text {Simpler geht es nicht! - Doch, kann die äusseren Klammern weglassen:
} 9.0 text {
} 10.0 text {class variable 
} 11.0 text {     set {...} 
} 12.0 text {     get {...} 
} 13.0 text {     ... 
} 14.0 text {
} 15.0 text {Aber das ist wohl zuviel für Tcler? Vielleicht so
} 16.0 text {class variable 
} 17.0 text {set {...} 
} 18.0 text {get {...} 
} 19.0 text {... 
} 20.0 text {Nein, ignoriert Zugehörigkeit zu class.
} 21.0 text { } 22.0

GetItem geflickt.
Objecttype => Class - das Konzept bereinigen. - deutlich eleganter. Noch eleganter wäre :

class variable {
	set   {...}
	get   {...}
} 

Simpler geht es nicht! - Doch, kann die äusseren Klammern weglassen:

class variable 
     set {...} 
     get {...} 
     ... 

Aber das ist wohl zuviel für Tcler? Vielleicht so
class variable 
set {...} 
get {...} 
... 
Nein, ignoriert Zugehörigkeit zu class.




  0.004 Messages Liste - schon vorhanden! 

mark insert 1.0 mark current 1.0 text {set messages { set get go come ... };  Message vorhanden wenn lsearch >=0 
} 1.0 text {!? Die Liste ist überflüssig, } 2.0 tagon i 2.30 text {jede Class hat ihre eigene Liste. } 2.30 tagoff i 2.64 text {schon. bereits.
} 2.64 text {Nochmals einfacher. Der Message Mechnismus ist überflüssig.
} 3.0 text {
} 4.0 text {wordcode => words } 5.0

set messages { set get go come ... };  Message vorhanden wenn lsearch >=0 
!? Die Liste ist überflüssig, jede Class hat ihre eigene Liste. schon. bereits.
Nochmals einfacher. Der Message Mechnismus ist überflüssig.

wordcode => words




  0.005 Kommentare 

mark insert 1.0 mark current 1.0 text {Kommentarzeilen # und \ bei gets $f erfassen und Zeilen ignorieren. Auch im Code.
} 1.0 text {
} 2.0 text {String ok, Forth Konvention " der string fängt mit einem Leerszeichen an"} 3.0 mark tk::anchor.work.page.panes.t.text 3.73 text {
} 3.73 text { } 4.0

Kommentarzeilen # und \ bei gets $f erfassen und Zeilen ignorieren. Auch im Code.

String ok, Forth Konvention " der string fängt mit einem Leerszeichen an"




  0.006 CompileColon und Objekte 

mark insert 1.0 mark current 1.0 text {Compiler Code hat Leerzeile wenn der Code auf der folgenden Zeile beginnt. Auf null spaces getrimmt.
} 1.0 text {: spaces  ( -- )   times .. repeat  ;  [ohne locals] : compiliert ok 
} 2.0 text {Zangengeburt. Dafür ist der Code schön geworden.
} 3.0 mark tk::anchor.work.page.panes.t.text 4.0 text {
} 4.0 text { } 5.0

Compiler Code hat Leerzeile wenn der Code auf der folgenden Zeile beginnt. Auf null spaces getrimmt.
: spaces  ( -- )   times .. repeat  ;  [ohne locals] : compiliert ok 
Zangengeburt. Dafür ist der Code schön geworden.




  0.007 \ im Source - Wortfolge 

mark insert 1.0 mark current 1.0 text {Reihenfolge der Definitionen ist wichtig. Weil jedes Wort in der Definition sich selbst compiliert. 
} 1.0 text {\ nur am Anfang der Zeile? - wäre aber nützlich auch im Text. 
} 2.0 text {- SkipLine macht das jetzt möglich. \ überall im Source erkannt. 
} 3.0 text {
} 4.0 tagon i 5.0 text {Die Reihenfolge der Worte muss strikt sein, erst definieren dann brauchen. Weil die Worte sich selbst compilieren. War das bei HolonT auch so?} 5.0 tagoff i 5.142 text {
} 5.142 text {
} 6.0 text {Globale Objekte mit :: ablegen! Aber erst auf local testen, weil es gibt auch Doppelgänger.
} 7.0 text {
} 8.0 text {Und dann spiel Chess ok.} 9.0 mark tk::anchor.work.page.panes.t.text 9.24 text {
} 9.24 text { } 10.0

Reihenfolge der Definitionen ist wichtig. Weil jedes Wort in der Definition sich selbst compiliert. 
\ nur am Anfang der Zeile? - wäre aber nützlich auch im Text. 
- SkipLine macht das jetzt möglich. \ überall im Source erkannt. 

Die Reihenfolge der Worte muss strikt sein, erst definieren dann brauchen. Weil die Worte sich selbst compilieren. War das bei HolonT auch so?

Globale Objekte mit :: ablegen! Aber erst auf local testen, weil es gibt auch Doppelgänger.

Und dann spiel Chess ok.




  0.008 CLI 

mark insert 1.0 mark current 1.0 text {Command Line Interpreter zeigt Stack, macht neues Colonwort, ist soweit nett.
} 1.0 text {Aber öffnet kein neues Chessspiel. Kann ausgebaut werden.
} 2.0 text {Immerhin. ... 
} 3.0 text {LoadLine mit catch. 
} 4.0 text {
} 5.0 text {Targetfile Versuch. File geschrieben. pop und push fehlen. - nur die Ruhe! später. } 6.0

Command Line Interpreter zeigt Stack, macht neues Colonwort, ist soweit nett.
Aber öffnet kein neues Chessspiel. Kann ausgebaut werden.
Immerhin. ... 
LoadLine mit catch. 

Targetfile Versuch. File geschrieben. pop und push fehlen. - nur die Ruhe! später.




  0.009 Turnkey-App bilden = Targetfile 

mark insert 1.0 mark current 1.0 text {Turnkeyfile der Applikation nebenbei produzieren, (Glück gehabt), 
} 1.0 text {einfach puts comp(code) auch auf das Targetfile target.tcl.
} 2.0 text {Wird immer neu produziert beim Laden des Source. 
} 3.0 text {Bedingung: comp(code) enthält den Zielcode einer Programmeinheit. 
} 4.0 text { } 5.0

Turnkeyfile der Applikation nebenbei produzieren, (Glück gehabt), 
einfach puts comp(code) auch auf das Targetfile target.tcl.
Wird immer neu produziert beim Laden des Source. 
Bedingung: comp(code) enthält den Zielcode einer Programmeinheit.




  0.010 Forth Console 1 

mark insert 1.0 mark current 1.0 text {Fenster mit Eingabezeile und Resultaten, Stackanzeige, Zeilen speichern und zurückholen. 
} 1.0 text {
} 2.0 text {Targetfile lässt sich nicht mehr öffnen für Compilieren. Consolefenster bauen ohne Targetfile. Sowieso nicht zu ende gedacht.
} 3.0 text {
} 4.0 text {Console als Textfenster, binden an <Return>, schickt Zeile zum laden. 
} 5.0 text {Console in . als .con.
} 6.0 text {Das funktioniert an sich ok, aber wenn ein Textfenster Console spielt, dann muss puts umdefiniert werden. Und das wird kompliziert. Besser wäre eine Tcl Console und das simple quit. Wobei ich dann ins Schleudern komme mit der Zeilenhistory.
} 7.0 text {Wie kann ich in der Console Zeilen zeigen und löschen?
} 8.0 text {Kombination von Tcl-Console und Entry?
} 9.0 text {stdout ist die Tcl-Console.
} 10.0 text {
} 11.0 mark tk::anchor.work.page.panes.t.text 12.0 text {
} 12.0 text { } 13.0

Fenster mit Eingabezeile und Resultaten, Stackanzeige, Zeilen speichern und zurückholen. 

Targetfile lässt sich nicht mehr öffnen für Compilieren. Consolefenster bauen ohne Targetfile. Sowieso nicht zu ende gedacht.

Console als Textfenster, binden an <Return>, schickt Zeile zum laden. 
Console in . als .con.
Das funktioniert an sich ok, aber wenn ein Textfenster Console spielt, dann muss puts umdefiniert werden. Und das wird kompliziert. Besser wäre eine Tcl Console und das simple quit. Wobei ich dann ins Schleudern komme mit der Zeilenhistory.
Wie kann ich in der Console Zeilen zeigen und löschen?
Kombination von Tcl-Console und Entry?
stdout ist die Tcl-Console.




  0.011 Forth Console 2 

mark tk::anchor.work.page.panes.t.text 1.0 mark insert 1.0 mark current 1.0 text {Tcl Console auch für Forth brauchen mit Quit. - nein
} 1.0 text {+ simpel, auch Tcl Worte testen und untersuchen
} 2.0 text {- nicht elegant, wie die Zeilen History machen? s. TkCon, kann es.
} 3.0 text {Wie kriege ich eine Console ohne TkCon. 
} 4.0 text { } 5.0

Tcl Console auch für Forth brauchen mit Quit. - nein
+ simpel, auch Tcl Worte testen und untersuchen
- nicht elegant, wie die Zeilen History machen? s. TkCon, kann es.
Wie kriege ich eine Console ohne TkCon.




  0.012 








  0.013 Forth Entry & Tcl Console 

mark insert 1.0 mark current 1.0 text {Die einfache Lösung. Forth Commandline und Tcl Console für Output. 
} 1.0 text {Forth CLI mit label und entry.
} 2.0 text {Tcl console = Tk console. 
} 3.0 text {Konsolenteile zusammenhängen, zumindest beim Start schön untereinander gruppieren. 
} 4.0 text {Forth command line und Codefenster kein Problem.
} 5.0 text {Aber wie arrangiere ich die Tk Console? Kenne den Namen nicht und kann nicht zugreifen. Scheint ein eigenes Toplevel zu sein. 
} 6.0 text {- die anderen Fenster darauf beziehen. Tk Console wird relativ zu den vorigen Fenstern positioniert, 
} 7.0 text {
} 8.0 text {Codefenster in Forthconsole integrieren statt eigenes Fenster. - Rev. 0.017} 9.0 mark tk::anchor.work.page.panes.t.text 9.75 text {
} 9.75 text {
} 10.0 text {=> es ist doch nicht die einfache Lösung. 
} 11.0 text {Komme um eine eigene volle Forthkonsole nicht herum. TclForth soll Forth sein, Tcl kann zusätzlich angeschaut werden mit console show, falls das jemand will. Aber normal soll der Programmierer ein Forthfenster sehen. - } 12.0

Die einfache Lösung. Forth Commandline und Tcl Console für Output. 
Forth CLI mit label und entry.
Tcl console = Tk console. 
Konsolenteile zusammenhängen, zumindest beim Start schön untereinander gruppieren. 
Forth command line und Codefenster kein Problem.
Aber wie arrangiere ich die Tk Console? Kenne den Namen nicht und kann nicht zugreifen. Scheint ein eigenes Toplevel zu sein. 
- die anderen Fenster darauf beziehen. Tk Console wird relativ zu den vorigen Fenstern positioniert, 

Codefenster in Forthconsole integrieren statt eigenes Fenster. - Rev. 0.017

=> es ist doch nicht die einfache Lösung. 
Komme um eine eigene volle Forthkonsole nicht herum. TclForth soll Forth sein, Tcl kann zusätzlich angeschaut werden mit console show, falls das jemand will. Aber normal soll der Programmierer ein Forthfenster sehen. -




  0.014 Forth-Fenster 

mark insert 1.0 mark current 1.0 text {TclForth startet in einem Forth Fenster mit einem CLI. Das Fenster kann wahlweise den compilierten Code zeigen und einen Editor haben für eine neue Programmunit, je in eigenem Fenster.
} 1.0 text {Forth Console tut, Zeile erfassen mit GetLine, LoadLine schreibt ok>. Und dann geht der Zeiger auf die nächste Zeile, warum?
} 2.0 text {-- weil bind <Return> nicht mit break endet. 
} 3.0 mark tk::anchor.work.page.panes.t.text 4.0 text {GetItem hat nicht gerne Leerraum am Ende der Zeile. Weiss nicht warum trotzdem die Forth Files geladen werden, sind die alle sauber?. - Test mit Unit scaleTag in tk.fth zwei Spaces am Codeende. Kein Problem. Weil EmptyLine die Zeile hinten trimmt. 
} 4.0 text {-- GetLine trimmen.
} 5.0 text {Vektorisieren mit rename. print und printnl einführen. Umdefinieren mit rename. Sicherheitscheck dass nicht bereits umgesetzt.
} 6.0 text {-> puts ersetzen durch print, print-tcl, print-fth und so.
} 7.0 text { } 8.0

TclForth startet in einem Forth Fenster mit einem CLI. Das Fenster kann wahlweise den compilierten Code zeigen und einen Editor haben für eine neue Programmunit, je in eigenem Fenster.
Forth Console tut, Zeile erfassen mit GetLine, LoadLine schreibt ok>. Und dann geht der Zeiger auf die nächste Zeile, warum?
-- weil bind <Return> nicht mit break endet. 
GetItem hat nicht gerne Leerraum am Ende der Zeile. Weiss nicht warum trotzdem die Forth Files geladen werden, sind die alle sauber?. - Test mit Unit scaleTag in tk.fth zwei Spaces am Codeende. Kein Problem. Weil EmptyLine die Zeile hinten trimmt. 
-- GetLine trimmen.
Vektorisieren mit rename. print und printnl einführen. Umdefinieren mit rename. Sicherheitscheck dass nicht bereits umgesetzt.
-> puts ersetzen durch print, print-tcl, print-fth und so.




  0.015 Forth Console 3 

mark insert 1.0 mark current 1.0 text {Befehle hinter ok> eingeben, Resultate auf den folgenden Zeilen, ok> auf der nächsten Zeile.
} 1.0 text {Keine Leerzeilen ausser gewollt. 
} 2.0 text {Fehler in der Console catchen.
} 3.0 text {Bei leerer Befehlszeile ein neues ok> schreiben.
} 4.0 text {Stack zeigen  ok> ( 3 44 5 - ) dup .
} 5.0 text {Forth } 6.0 mark tk::anchor.work.page.panes.t.text 6.6 text {Befehle: tcl ShowStack, tcl HideStack
} 6.6 text { } 7.0

Befehle hinter ok> eingeben, Resultate auf den folgenden Zeilen, ok> auf der nächsten Zeile.
Keine Leerzeilen ausser gewollt. 
Fehler in der Console catchen.
Bei leerer Befehlszeile ein neues ok> schreiben.
Stack zeigen  ok> ( 3 44 5 - ) dup .
Forth Befehle: tcl ShowStack, tcl HideStack




  0.016 Forth Console History 

mark insert 1.0 mark current 1.0 text {frühere Entry History übernehmen mit einsetzen in das Textwidget.
} 1.0 text {Fenster hochscrollen wenn unten. yview moveto 0.9
} 2.0 text {? Scrollbar
} 3.0 text {Leerraum unten -pady 20 - gibt auch Leerraum oben, so what.
} 4.0 text {ok statt ok> 
} 5.0 text {Stack zeigen ohne (), also   ok -     ok 33 -    ok 33 44 {some text} - : ja klarer
} 6.0 mark tk::anchor.work.page.panes.t.text 7.0 text {ok hinten   33 44 - ok : ja, wenn bei leerem Stack ok ohne Strich. und besser mit ok>.
} 7.0 text {
} 8.0 text { } 9.0

frühere Entry History übernehmen mit einsetzen in das Textwidget.
Fenster hochscrollen wenn unten. yview moveto 0.9
? Scrollbar
Leerraum unten -pady 20 - gibt auch Leerraum oben, so what.
ok statt ok> 
Stack zeigen ohne (), also   ok -     ok 33 -    ok 33 44 {some text} - : ja klarer
ok hinten   33 44 - ok : ja, wenn bei leerem Stack ok ohne Strich. und besser mit ok>.




  0.017 Console & Codefenster 

mark insert 1.0 mark current 1.0 text {Codefenster unten anhängen. 
} 1.0 text {Stackanzeige ohne - :  22 33 ok> 
} 2.0 text {Polituren
} 3.0 text { } 4.0

Codefenster unten anhängen. 
Stackanzeige ohne - :  22 33 ok> 
Polituren




  0.018 Interpretersachen 

mark insert 1.0 mark current 1.0 text {Stack underflow erfasst. 
} 1.0 text {
} 2.0 text {0.019 Delay in EvalLine nach Error, damit der Insertcursor Zeit hat hinter ok> zu kommen
} 3.0 text {
} 4.0 text { } 5.0

Stack underflow erfasst. 

0.019 Delay in EvalLine nach Error, damit der Insertcursor Zeit hat hinter ok> zu kommen




  0.019 App Chess 

mark insert 1.0 text {Chess.fth ist gedacht für laden in Tk Fenster .
} 1.0 text {Was ja auch normal ist für eine Applikation.
} 2.0 text {Jetzt wird es in die Forthconsole geladen weil diese auch in . liegt. 
} 3.0 text {Nach dem Laden bleibt ein .c auf dem Stack. So what.
} 4.0 text {Turnkey bilden: 
} 5.0 text {Loadfile chess.tcl
} 6.0 text {	source source/compiler.tcl} 7.0 mark current 7.27 text {
} 7.27 text {	LoadForth source/forth.fth
} 8.0 text {	LoadForth source/tk.fth
} 9.0 text {	LoadForth source/chess.fth
} 10.0 text {Execute chess.command
} 11.0 text {	cd holon/holontf
} 12.0 text {	./tclkit85 ./source/chess} 13.0 mark tk::anchor.work.page.panes.t.text 13.26 text {.tcl &
} 13.26 text {
} 14.0 text {
} 15.0 text { } 16.0

Chess.fth ist gedacht für laden in Tk Fenster .
Was ja auch normal ist für eine Applikation.
Jetzt wird es in die Forthconsole geladen weil diese auch in . liegt. 
Nach dem Laden bleibt ein .c auf dem Stack. So what.
Turnkey bilden: 
Loadfile chess.tcl
	source source/compiler.tcl
	LoadForth source/forth.fth
	LoadForth source/tk.fth
	LoadForth source/chess.fth
Execute chess.command
	cd holon/holontf
	./tclkit85 ./source/chess.tcl &




  0.020 Forthconsole in .fth // Stack "text" // Chess 

mark insert 1.0 text {Commandline History wäre klarer in Forth. Die Compilerworte müssten Code sein. ? in compiler.tcl legen.
} 1.0 text {
} 2.0 text {Stack: Textargumente: neben  " arg"   auch "arg" zulassen, vor allem als Indizes in arrays einfacher:
} 3.0 text {{ wie 33 was 44 wo 55 } array frage         "wie" frage .   statt    " wie" frage . - gemacht} 4.0 mark tk::anchor.work.page.panes.t.text 4.93 text {
} 4.93 text {
} 5.0 text {Chess.fth korrigiert. } 6.0

Commandline History wäre klarer in Forth. Die Compilerworte müssten Code sein. ? in compiler.tcl legen.

Stack: Textargumente: neben  " arg"   auch "arg" zulassen, vor allem als Indizes in arrays einfacher:
{ wie 33 was 44 wo 55 } array frage         "wie" frage .   statt    " wie" frage . - gemacht

Chess.fth korrigiert.




  0.021 Tk widgets 

mark insert 1.0 mark current 1.0 text {?? Finde keine bessere Syntax als Tk. Muss halt Codeworte bilden. 
} 1.0 text {
} 2.0 text {Versuch: Class widget
} 3.0 text {Use: "type window" widget <name> -- An instance of type contained in window is created as the variable name.
} 4.0 text {Example: "text $frame.forth" widget Console
} 5.0 text {"-relief sunken -color blue" Console config -- list of property & value pairs. property with or without dash -relief 
} 6.0 text {
} 7.0 text {code theBoard ( -- )
} 8.0 text {    frame .f
} 9.0 text {    label  .f.e -width 30 -anchor w -textvar info -relief sunken
} 10.0 text {    button .f.u -text Undo  -command {undo; push .c; drawSetup }
} 11.0 text {    button .f.r -text Reset -command {reset; push .c; drawSetup}
} 12.0 text {    button .f.f -text Flip  -command {push .c; flipSides}
} 13.0 text {    eval pack [winfo children .f] -side left -fill both
} 14.0 text {    pack .f -fill x -side bottom
} 15.0 text {    pack .c -fill both -expand 1
} 16.0 text {    trace add variable ::toMove write doMoveInfo 
} 17.0 text {    bind . ?         {console show}} 18.0 mark tk::anchor.work.page.panes.t.text 18.35 text {
} 18.35 text {    bind . <Escape> {exit}
} 19.0 text {    set ::info "white to move"
} 20.0 text {    wm title . "Chess in Forth"
} 21.0 text {
} 22.0 text {: theBoard ( -- )
} 23.0 text {	"frame .f" widget CF
} 24.0 text {	"label $CF.e" widget CL  "-width 30 -anchor w -textvar info -relief sunken" CL config
} 25.0 text {?	"-width 30 -anchor w -textvar info -relief sunken label $CF.e" widget CL 
} 26.0 text {	"button .f.u" widget BU   "-text Undo  -command {undo; push .c; drawSetup}" BU config  	
} 27.0 text {	CF children "-side left -fill both" pack
} 28.0 text {	"-fill x -side bottom" CF pack
} 29.0 text {	"-fill both -expand 1" CW pack
} 30.0 text { 
} 31.0 text {Je Class pro Widget Typ
} 32.0 text {: theBoard ( -- )
} 33.0 text {	".f" frame cwin 
} 34.0 text {	".f.e" label cboard  "-width 30 -anchor w -textvar info -relief sunken" c-oard config
} 35.0 text {	"$cwin.u" button bUndo  "-text Undo  -command {undo; push .c; drawSetup}" bUndo config  	
} 36.0 text {	"-side left -fill both"	cwin children pack
} 37.0 text {	"-fill x -side bottom" cwin pack
} 38.0 text {	"-fill both -expand 1" CW pack
} 39.0 text {
} 40.0 text {!	".f" frame cF   == set cF [frame .f]
} 41.0 text { 
} 42.0 text {	".c" canvas w  "-width 300 -height 300" w config } 43.0

?? Finde keine bessere Syntax als Tk. Muss halt Codeworte bilden. 

Versuch: Class widget
Use: "type window" widget <name> -- An instance of type contained in window is created as the variable name.
Example: "text $frame.forth" widget Console
"-relief sunken -color blue" Console config -- list of property & value pairs. property with or without dash -relief 

code theBoard ( -- )
    frame .f
    label  .f.e -width 30 -anchor w -textvar info -relief sunken
    button .f.u -text Undo  -command {undo; push .c; drawSetup }
    button .f.r -text Reset -command {reset; push .c; drawSetup}
    button .f.f -text Flip  -command {push .c; flipSides}
    eval pack [winfo children .f] -side left -fill both
    pack .f -fill x -side bottom
    pack .c -fill both -expand 1
    trace add variable ::toMove write doMoveInfo 
    bind . ?         {console show}
    bind . <Escape> {exit}
    set ::info "white to move"
    wm title . "Chess in Forth"

: theBoard ( -- )
	"frame .f" widget CF
	"label $CF.e" widget CL  "-width 30 -anchor w -textvar info -relief sunken" CL config
?	"-width 30 -anchor w -textvar info -relief sunken label $CF.e" widget CL 
	"button .f.u" widget BU   "-text Undo  -command {undo; push .c; drawSetup}" BU config  	
	CF children "-side left -fill both" pack
	"-fill x -side bottom" CF pack
	"-fill both -expand 1" CW pack
 
Je Class pro Widget Typ
: theBoard ( -- )
	".f" frame cwin 
	".f.e" label cboard  "-width 30 -anchor w -textvar info -relief sunken" c-oard config
	"$cwin.u" button bUndo  "-text Undo  -command {undo; push .c; drawSetup}" bUndo config  	
	"-side left -fill both"	cwin children pack
	"-fill x -side bottom" cwin pack
	"-fill both -expand 1" CW pack

!	".f" frame cF   == set cF [frame .f]
 
	".c" canvas w  "-width 300 -height 300" w config




  0.022 Widgets 2 

mark insert 1.0 mark current 1.0 text {? Kann eine Class in colon code, in einer proc, gebildet werden? ja:
} 1.0 text {Class Objekte in } 2.0 tagon b 2.17 text {uplevel #0} 2.17 tagoff b 2.27 text { bilden. Bsp. tktext:  instance code = uplevel #0 {set obj [pop]; text $obj} 
} 2.27 text {
} 3.0 text { } 4.0

? Kann eine Class in colon code, in einer proc, gebildet werden? ja:
Class Objekte in uplevel #0 bilden. Bsp. tktext:  instance code = uplevel #0 {set obj [pop]; text $obj}




  0.023 Console GetLine History: Textanfang 

mark insert 1.0 mark current 1.0 text {Die Position nach dem Prompt kann falsch sein nach einem Fehler. Aus internen Zeitverschiebungen.
} 1.0 text {Es wäre besser, den Start des Consolentextes bei RETURN zu bestimmen.
} 2.0 text {Oder doch nach einer Verzögerung? Ja aber ohne das Programm anzuhalten!!} 3.0 mark tk::anchor.work.page.panes.t.text 3.72 text {
} 3.72 text { } 4.0

Die Position nach dem Prompt kann falsch sein nach einem Fehler. Aus internen Zeitverschiebungen.
Es wäre besser, den Start des Consolentextes bei RETURN zu bestimmen.
Oder doch nach einer Verzögerung? Ja aber ohne das Programm anzuhalten!!




  0.024 Widgets 3 configure 

mark insert 1.0 mark current 1.0 text {.f config "-relief sunken -border 3" geht nicht, muss -relief sunken -border 3 sein ohne ". 
} 1.0 text {Bzw ein String mit config drin, und das dann eval? ja
} 2.0 text {
} 3.0 text {? Class widget allgemein
} 4.0 text {.f widget frame fWindow
} 5.0 text {.f.c widget text fConsole
} 6.0 tagon i 7.0 text {-- nein, jedes Widget hat eigene Commands.} 7.0 tagoff i 7.42 text {
} 7.42 text {
} 8.0 text {uvam
} 9.0 text {
} 10.0 text { 
} 11.0 text {Forth Console in Forth
} 12.0 text { 
} 13.0 text {
} 14.0 text {erst mal committen
} 15.0 text { } 16.0

.f config "-relief sunken -border 3" geht nicht, muss -relief sunken -border 3 sein ohne ". 
Bzw ein String mit config drin, und das dann eval? ja

? Class widget allgemein
.f widget frame fWindow
.f.c widget text fConsole
-- nein, jedes Widget hat eigene Commands.

uvam

 
Forth Console in Forth
 

erst mal committen




  0.025 Forth Console in Forth 

mark insert 1.0 mark current 1.0 text {Es funktioniert tatsächlich.
} 1.0 text {Mit Codeworten.
} 2.0 text {Noch einige Fragen. In neuer Revision...
} 3.0 mark tk::anchor.work.page.panes.t.text 4.0 text {
} 4.0 text {> "command" msec doafter   -- kein Script statt command möglich? } 5.0

Es funktioniert tatsächlich.
Mit Codeworten.
Noch einige Fragen. In neuer Revision...

> "command" msec doafter   -- kein Script statt command möglich?




  0.026 Console polieren 

mark insert 1.0 text {: tt ( -- ) { some command } 500 doafter -- die {} sollte auf dem Stack landen als { script } unverändert. - das tut es auch. 
} 1.0 text {Warum hat es in okprompt nicht geklappt?  Das Skript muss compiliert auf den Stack kommen also in } 2.0 tagon i 2.98 text {Tcl code} 2.98 tagoff i 2.106 text {. 
} 2.106 text {
} 3.0 text {okprompt } 4.0 tagon i 4.9 text update 4.9 tagoff i 4.15 text { statt delay - ok
} 4.15 text {
} 5.0 text {Console nach oben schieben wenn die Commandline unten ankommt, immer zwei Leerzeilen darunter. - Bug: moveto vergessen.
} 6.0 text {1.0 Console yview. 
} 7.0 mark current 8.0 text {
} 8.0 text {Commandhistory debuggen, com- un} 9.0 mark tk::anchor.work.page.panes.t.text 9.32 text {d com+ vertauschen!
} 9.32 text {
} 10.0 text {ok> ganz links wenn kein Stack oder leer.
} 11.0 text {
} 12.0 text {
} 13.0 text {
} 14.0 text {
} 15.0 text {
} 16.0 text {
} 17.0 text {
} 18.0 text {
} 19.0 text {
} 20.0 text { } 21.0

: tt ( -- ) { some command } 500 doafter -- die {} sollte auf dem Stack landen als { script } unverändert. - das tut es auch. 
Warum hat es in okprompt nicht geklappt?  Das Skript muss compiliert auf den Stack kommen also in Tcl code. 

okprompt update statt delay - ok

Console nach oben schieben wenn die Commandline unten ankommt, immer zwei Leerzeilen darunter. - Bug: moveto vergessen.
1.0 Console yview. 

Commandhistory debuggen, com- und com+ vertauschen!

ok> ganz links wenn kein Stack oder leer.




  0.027 div. 

mark insert 1.0 mark current 1.0 text {decr 
} 1.0 text {
} 2.0 text {pack mit null Options - leeren Options-String liefern!
} 3.0 text {
} 4.0 text {config mit null Options zum Auslesen der Configuration: geht nicht. Lieber in Tcl console.
} 5.0 text {
} 6.0 text {Stacknotation ( -- )  = (-) = () -- nein ( -- ) ist klar, soviel Arbeit muss sein!
} 7.0 text {
} 8.0 text {Commandline details:
} 9.0 text {.forth ersetzt durch $::Console in den proc und code Worten 
} 10.0 text {
} 11.0 mark tk::anchor.work.page.panes.t.text 12.0 text { } 12.0

decr 

pack mit null Options - leeren Options-String liefern!

config mit null Options zum Auslesen der Configuration: geht nicht. Lieber in Tcl console.

Stacknotation ( -- )  = (-) = () -- nein ( -- ) ist klar, soviel Arbeit muss sein!

Commandline details:
.forth ersetzt durch $::Console in den proc und code Worten




  0.028 Parsen 

mark insert 1.0 mark current 1.0 text {"string" und {list} zusammenfassen, sind das gleiche in Tcl. 
} 1.0 text {Der Stringtext kann als eine Folge von Listelementen verarbeitet werden.
} 2.0 text {Wie finde ich den Stringindex für das n-te Element in einer Liste? 
} 3.0 text {Vorerst bei der Stringmethode bleiben.
} 4.0 text { 
} 5.0 text {comp(current) => comp(prev), 
} 6.0 text {comp(imax) => comp(end), 
} 7.0 text {comp(source) => comp(text) 
} 8.0 text {
} 9.0 text >\ Fall\ Keine\ End-\"\ oder\ kein\ End-\}\ \n 10.0 text {
} 11.0 mark tk::anchor.work.page.panes.t.text 12.0 text { } 12.0

"string" und {list} zusammenfassen, sind das gleiche in Tcl. 
Der Stringtext kann als eine Folge von Listelementen verarbeitet werden.
Wie finde ich den Stringindex für das n-te Element in einer Liste? 
Vorerst bei der Stringmethode bleiben.
 
comp(current) => comp(prev), 
comp(imax) => comp(end), 
comp(source) => comp(text) 

> Fall Keine End-" oder kein End-}




  0.029 {text} und {list} und simpel 

mark insert 1.0 mark current 1.0 text {if {[isNoString]&&[isNoList]} {error "$comp(word) is undefined"}
} 1.0 text -- 2.0 mark tk::anchor.work.page.panes.t.text 2.2 text {
} 2.2 text {PushText für " tttt" und "tttt", do. PushList } 3.0

if {[isNoString]&&[isNoList]} {error "$comp(word) is undefined"}
--
PushText für " tttt" und "tttt", do. PushList




  0.030 Console Menus 

mark insert 1.0 mark current 1.0 text {Menus erst in Tcl bauen. Dann eine Forth Version probieren. Aus Holon kopieren. 
} 1.0 text {Kein Contextmenu, unnötig kompliziert. Menu Setup kann die Console löschen. 
} 2.0 text {
} 3.0 mark tk::anchor.work.page.panes.t.text 4.0 text { } 4.0

Menus erst in Tcl bauen. Dann eine Forth Version probieren. Aus Holon kopieren. 
Kein Contextmenu, unnötig kompliziert. Menu Setup kann die Console löschen.




  0.031 Code mit { }  Colon mit : ; 

mark insert 1.0 mark current 1.0 text {?? CODE WORTE MIT {   } 
} 1.0 text {+: deutlich zeigen dass es Tcl ist -- wahrscheinlich ist das weniger verwirrend. Die Leute wollen wohl Begrenzerzeichen haben im Source. -- Ich bin für mich zu radikal. 
} 2.0 text {-: der Source wird polluted! All die schönen kurzen Kernelworte werden verhunzt. Die Leute sollen sich an eine einfachere Welt gewöhnen. ICH finde es schöner! .. und ein bisschen später sehe auch ich, dass {} und ; richtig sind weil Code und Colon so aussehen bei allen anderen Leuten, und mir gefällt es auch. 
} 3.0 text {
} 4.0 text {MakeCode 
} 5.0 text -\ auf\ Anfangs-\{\ testen:\ erstes\ Wort\ nach\ der\ Stackdefinition\ muss\ \{\ sein.\ \n 6.0 text -\ auf\ End-\}\ testen:\ Letztes\ \}\ muss\ am\ Ende\ des\ Textes\ sein.\ string\ last\ ...\ \n 7.0 text -\ letztes\ \}\ und\ CR\ davor\ abschneiden.\ \n 8.0 text {Test: leerzeichen hinten anhängen. --werden von Holon abgeschnitten, muss File direkt behandeln. :: Ende ist falsch, muss trimmen.
} 9.0 text {EmptyLine - Test schneidet Leerraum vorne und hinten ab. 
} 10.0 text {
} 11.0 text {Alle Module umgesetzt auf { } und : ;
} 12.0 text {
} 13.0 text {--
} 14.0 text {
} 15.0 text {s. 0.047 
} 16.0 text { } 17.0

?? CODE WORTE MIT {   } 
+: deutlich zeigen dass es Tcl ist -- wahrscheinlich ist das weniger verwirrend. Die Leute wollen wohl Begrenzerzeichen haben im Source. -- Ich bin für mich zu radikal. 
-: der Source wird polluted! All die schönen kurzen Kernelworte werden verhunzt. Die Leute sollen sich an eine einfachere Welt gewöhnen. ICH finde es schöner! .. und ein bisschen später sehe auch ich, dass {} und ; richtig sind weil Code und Colon so aussehen bei allen anderen Leuten, und mir gefällt es auch. 

MakeCode 
- auf Anfangs-{ testen: erstes Wort nach der Stackdefinition muss { sein. 
- auf End-} testen: Letztes } muss am Ende des Textes sein. string last ... 
- letztes } und CR davor abschneiden. 
Test: leerzeichen hinten anhängen. --werden von Holon abgeschnitten, muss File direkt behandeln. :: Ende ist falsch, muss trimmen.
EmptyLine - Test schneidet Leerraum vorne und hinten ab. 

Alle Module umgesetzt auf { } und : ;

--

s. 0.047




  0.032 div. 

mark insert 1.0 mark current 1.0 text {par => stack
} 1.0 text {
} 2.0 text {Setupmenu: Open Tcl Console 
} 3.0 text {
} 4.0 text {EvalLine error zeigt comp(name) wenn } 5.0 mark tk::anchor.work.page.panes.t.text 5.37 text {der Fehler in einer Definition ist. } 5.37

par => stack

Setupmenu: Open Tcl Console 

EvalLine error zeigt comp(name) wenn der Fehler in einer Definition ist.




  0.033 okprompt 

mark insert 1.0 mark current 1.0 text {Bei okprompt wird "ok>" ans Ende des Textes geschrieben, aber der insert Ort im Text bleibt wo er war.
} 1.0 text {Neu auch den insert ans Ende setzen, als Teil von append. 
} 2.0 text {--
} 3.0 text {Ein Eintrag in der Commandgeschichte kann mehrere Zeilen umfassen. Wenn wir schon am Ende des Fensters sind, verschwinden die weiteren Zeilen unten, muss das Fenster neu richten. 
} 4.0 text {--
} 5.0 text {Jetzt macht die Console Spass. 
} 6.0 text {--
} 7.0 text {Im Forth-Tcl Code die ; mit einem Space vor und nach einsetzen. Dadurch unterschieden vom Tcl-Proc-Code und gut lesbar. } 8.0

Bei okprompt wird "ok>" ans Ende des Textes geschrieben, aber der insert Ort im Text bleibt wo er war.
Neu auch den insert ans Ende setzen, als Teil von append. 
--
Ein Eintrag in der Commandgeschichte kann mehrere Zeilen umfassen. Wenn wir schon am Ende des Fensters sind, verschwinden die weiteren Zeilen unten, muss das Fenster neu richten. 
--
Jetzt macht die Console Spass. 
--
Im Forth-Tcl Code die ; mit einem Space vor und nach einsetzen. Dadurch unterschieden vom Tcl-Proc-Code und gut lesbar.




  0.034 Test Class mit Kommentar 

mark insert 1.0 mark current 1.0 text {Class variable  
} 1.0 text {\	Message    Method	
} 2.0 text {\     -----------------------------
} 3.0 text {	instance	   {set obj [pop]}
} 4.0 text {	""		   {push $obj}
} 5.0 text {	get		   {push $obj}
} 6.0 text {	@		   {push $obj}
} 7.0 text {	put		   {set obj [pop]}
} 8.0 text {	!		   {set obj [pop]}
} 9.0 text {	set		   {set obj [pop]}
} 10.0 text {	incr		   {incr obj}
} 11.0 text {	decr		   {incr obj -1}
} 12.0 text {	add		   {set obj [expr {$obj+[pop]}]}
} 13.0 text {	print		   {print $obj}
} 14.0 text {	tolower		   {push [string tolower $obj]}
} 15.0 text {
} 16.0 text {Sieht klumpig aus. Genügt es im Manual zu zeigen.} 17.0 mark tk::anchor.work.page.panes.t.text 17.49 text {
} 17.49 text { } 18.0

Class variable  
\	Message    Method	
\     -----------------------------
	instance	   {set obj [pop]}
	""		   {push $obj}
	get		   {push $obj}
	@		   {push $obj}
	put		   {set obj [pop]}
	!		   {set obj [pop]}
	set		   {set obj [pop]}
	incr		   {incr obj}
	decr		   {incr obj -1}
	add		   {set obj [expr {$obj+[pop]}]}
	print		   {print $obj}
	tolower		   {push [string tolower $obj]}

Sieht klumpig aus. Genügt es im Manual zu zeigen.




  0.035 Chess, Console 








  0.036 Command History 

mark insert 1.0 mark current 1.0 text {Command history überarbeitet. ctext ist überflüssig.
} 1.0 text -- 2.0 mark tk::anchor.work.page.panes.t.text 2.2 text {
} 2.2 text {ShowWords im HelpMenu.
} 3.0 text { } 4.0

Command history überarbeitet. ctext ist überflüssig.
--
ShowWords im HelpMenu.




  0.037 Class Menu 

mark insert 1.0 mark current 1.0 text {Class Menu begonnen, aber jetzt ist genug... } 1.0

Class Menu begonnen, aber jetzt ist genug...




  0.038 Starkit bauen 

mark insert 1.0 mark current 1.0 text {Kit Verzeichnis: 
} 1.0 text { 
} 2.0 text {tclforth.vfs
} 3.0 text {     main.tcl
} 4.0 text {     app-tclforth     
} 5.0 text {          compiler.tcl
} 6.0 text {          forth.tcl
} 7.0 text {          tk.tcl
} 8.0 text {          tfmain.tcl
} 9.0 text {          chess.fth
} 10.0 text {
} 11.0 tagon i 12.0 text main.tcl 12.0 tagoff i 12.8 text {
} 12.8 text {package require starkit
} 13.0 text {starkit::startup
} 14.0 text {set dir $starkit::topdir
} 15.0 text {cd $dir/app-tclforth
} 16.0 text {source tfmain.tcl
} 17.0 text {
} 18.0 tagon i 19.0 text tfmain.tcl 19.0 tagoff i 19.10 text {
} 19.10 text {source compiler.tcl
} 20.0 text {LoadForth forth.fth
} 21.0 text {LoadForth tk.fth
} 22.0 text {LoadForth console.fth} 23.0 mark tk::anchor.work.page.panes.t.text 23.21 text {
} 23.21 text {catch {console show}
} 24.0 text {puts "Tcl console"
} 25.0 text {ForthConsole
} 26.0 text {
} 27.0 text {
} 28.0 text {makekit.command - in Terminal rufen
} 29.0 text {cd /Users/wolf/Holon/HolonTF/Starpack
} 30.0 text {rm ./tclforth.vfs/app-tclforth/*.*
} 31.0 text {# Files kopieren
} 32.0 text {cp ../source/compiler.tcl  ./tclforth.vfs/app-tclforth/
} 33.0 text {cp ../source/forth.fth  ./tclforth.vfs/app-tclforth/
} 34.0 text {cp ../source/tk.fth  ./tclforth.vfs/app-tclforth/
} 35.0 text {cp ../source/console.fth  ./tclforth.vfs/app-tclforth/
} 36.0 text {cp ../source/tfmain.tcl  ./tclforth.vfs/app-tclforth/
} 37.0 text {cp ../source/chess.fth  ./tclforth.vfs/app-tclforth/
} 38.0 text {./tclkit85 sdx.kit wrap tclforth.kit
} 39.0 text {
} 40.0 text {RunKit.command
} 41.0 text {cd /Users/wolf/Holon/HolonTF/Starpack
} 42.0 text {./tclkit85 tclforth.kit &
} 43.0 text { } 44.0

Kit Verzeichnis: 
 
tclforth.vfs
     main.tcl
     app-tclforth     
          compiler.tcl
          forth.tcl
          tk.tcl
          tfmain.tcl
          chess.fth

main.tcl
package require starkit
starkit::startup
set dir $starkit::topdir
cd $dir/app-tclforth
source tfmain.tcl

tfmain.tcl
source compiler.tcl
LoadForth forth.fth
LoadForth tk.fth
LoadForth console.fth
catch {console show}
puts "Tcl console"
ForthConsole


makekit.command - in Terminal rufen
cd /Users/wolf/Holon/HolonTF/Starpack
rm ./tclforth.vfs/app-tclforth/*.*
# Files kopieren
cp ../source/compiler.tcl  ./tclforth.vfs/app-tclforth/
cp ../source/forth.fth  ./tclforth.vfs/app-tclforth/
cp ../source/tk.fth  ./tclforth.vfs/app-tclforth/
cp ../source/console.fth  ./tclforth.vfs/app-tclforth/
cp ../source/tfmain.tcl  ./tclforth.vfs/app-tclforth/
cp ../source/chess.fth  ./tclforth.vfs/app-tclforth/
./tclkit85 sdx.kit wrap tclforth.kit

RunKit.command
cd /Users/wolf/Holon/HolonTF/Starpack
./tclkit85 tclforth.kit &




  0.039 Run mit mail.tcl für tkmail.tcl 

mark insert 1.0 mark current 1.0 text {source/tkmain.tcl  lädt  files im selben verzeichnis, d.h. pwd muss in source/ zeigen.
} 1.0 text {
} 2.0 text {run tclforth1.command =
} 3.0 text {cd holon/holontf/source
} 4.0 text {../tclkit85 ./tfmain.tcl &
} 5.0 text {funktioniert nicht
} 6.0 text {
} 7.0 text {run tclforth.command =
} 8.0 text {cd holon/holontf
} 9.0 text {./tclkit85 ./source/main.tcl &} 10.0 mark tk::anchor.work.page.panes.t.text 10.30 text {
} 10.30 text {funktioniert mit 
} 11.0 text {
} 12.0 tagon b 13.0 text {main.tcl = 
} 13.0 text {cd ./source
} 14.0 text {source tfmain.tcl} 15.0 tagoff b 15.17 text {
} 15.17 text { 
} 16.0 text {weiss nicht warum
} 17.0 text {
} 18.0 text {beide tclforth.command varianten funktioneren vom Finder aus.
} 19.0 text {aber nicht aus tcl heraus mit dem runcmd. } 20.0

source/tkmain.tcl  lädt  files im selben verzeichnis, d.h. pwd muss in source/ zeigen.

run tclforth1.command =
cd holon/holontf/source
../tclkit85 ./tfmain.tcl &
funktioniert nicht

run tclforth.command =
cd holon/holontf
./tclkit85 ./source/main.tcl &
funktioniert mit 

main.tcl = 
cd ./source
source tfmain.tcl
 
weiss nicht warum

beide tclforth.command varianten funktioneren vom Finder aus.
aber nicht aus tcl heraus mit dem runcmd.




  0.040 Source polieren für Googlecode 

mark insert 1.0 mark current 1.0 text {font configure code -family Monaco 
} 1.0 text {
} 2.0 text {isNoString, isNoList Logik umkehren 
} 3.0 text {
} 4.0 text {Kommentare einfügen in Source. 
} 5.0 text {
} 6.0 text {Fileköpfe wie man das so tut. } 7.0

font configure code -family Monaco 

isNoString, isNoList Logik umkehren 

Kommentare einfügen in Source. 

Fileköpfe wie man das so tut.




  0.041 Source weiter anpassen. 

mark insert 1.0 mark current 1.0 text {Codeworte einzeilig in eine Zeile. - Überzeugt nicht immer, habe gerne Parameter und Code getrennt.
} 1.0 text {
} 2.0 text {Compiler mit dem Code in  { } -- ja, ist klar und korrekt
} 3.0 text {Alles korrigiert.
} 4.0 text {MakeCompiler testet auf Anfangs-{ und End-} Klammern, d.h. beide müssen frei stehen. Syntax
} 5.0 text {
} 6.0 text compiler\ proc\ \ \{\n 7.0 text {	MakeProc
} 8.0 text \}\n 9.0 text { 
} 10.0 text {? compiler proc {MakeProc}  -  machbar?  
} 11.0 text {	E: } 12.0 mark tk::anchor.work.page.panes.t.text 12.4 text {Erstes Wort nach dem Namen muss mit { beginnen, letztes Wort muss mit } enden } 12.4

Codeworte einzeilig in eine Zeile. - Überzeugt nicht immer, habe gerne Parameter und Code getrennt.

Compiler mit dem Code in  { } -- ja, ist klar und korrekt
Alles korrigiert.
MakeCompiler testet auf Anfangs-{ und End-} Klammern, d.h. beide müssen frei stehen. Syntax

compiler proc  {
	MakeProc
}
 
? compiler proc {MakeProc}  -  machbar?  
	E: Erstes Wort nach dem Namen muss mit { beginnen, letztes Wort muss mit } enden




  0.042 do ... loop 

mark insert 1.0 mark current 1.0 text {es ist gut wie es ist, auch wenn es kompliziert ist, es funktioniert. 
} 1.0 text {
} 2.0 text {CodeWindow grösser } 3.0

es ist gut wie es ist, auch wenn es kompliziert ist, es funktioniert. 

CodeWindow grösser




  0.043 Chess 

mark insert 1.0 mark current 1.0 text {Polieren, Freiraum links.
} 1.0 text {Farben ändern, lasse es original, ist hübsch. Kein Grund zu ändern. } 2.0

Polieren, Freiraum links.
Farben ändern, lasse es original, ist hübsch. Kein Grund zu ändern.




  0.044 Objecttypes 

mark insert 1.0 mark current 1.0 text {Class ist irreführend, zu allgemein und umfassend. Muss zu OT zurück. 
} 1.0 text {Class => Objecttype, class => objtype. } 2.0

Class ist irreführend, zu allgemein und umfassend. Muss zu OT zurück. 
Class => Objecttype, class => objtype.




  0.045 Objecttype als Arrays zeigen? Kleinschrift 

mark insert 1.0 mark current 1.0 text {Mit Array Klammern ist es Tcl, ohne ist es Forth !? Ich liebe Forth... 
} 1.0 text {
} 2.0 text {objecttype klein geschrieben
} 3.0 text {compiler klein geschrieben 
} 4.0 text {--
} 5.0 text {macht mir Mühe - aber ist konsequent wegen proc - und ws Gewohnheitssache. -- technischer. ok
} 6.0 text {- aber Variable ? ist variable. } 7.0

Mit Array Klammern ist es Tcl, ohne ist es Forth !? Ich liebe Forth... 

objecttype klein geschrieben
compiler klein geschrieben 
--
macht mir Mühe - aber ist konsequent wegen proc - und ws Gewohnheitssache. -- technischer. ok
- aber Variable ? ist variable.




  0.046 do - code ohne {abstand} 

mark tk::anchor.work.page.panes.t.text 1.0 mark insert 1.0 mark current 1.0 text {::doi etc warum global? - weiss es nicht mehr aber es funktioniert auch mit Unterwort mit loop - weil das Wort früher definiert und damit die richtigen Indizes hat. 
} 1.0 text {
} 2.0 text {code - {ohne Abstand} - tut auch irgendwann. Frug mich kurz ob die Braces nötig sind. Jetzt tut es also lassen. } 3.0

::doi etc warum global? - weiss es nicht mehr aber es funktioniert auch mit Unterwort mit loop - weil das Wort früher definiert und damit die richtigen Indizes hat. 

code - {ohne Abstand} - tut auch irgendwann. Frug mich kurz ob die Braces nötig sind. Jetzt tut es also lassen.




  0.047 Code und Compiler ohne {} 

mark insert 1.0 mark current 1.0 text {Es war ein Irrtum, bin der "Eleganz" von Tcl erlegen. Ohne {} ist alles einfacher, Compiler und Forthsource. Forth ist einfach! 
} 1.0 text {
} 2.0 text {Für Tcl Leute ist es ungewohnt. Aber welcher Tcl Mensch will TclForth? Es ist für Forth Leute gemacht. 
} 3.0 text {- Könnte auch gerade formale Argumente einführen und Substitutionen, wenn mir die {} gefallen... 
} 4.0 text {
} 5.0 text {Auch die Sourcefiles werden kürzer und lesbarer, wenn auch weniger angenehm für Tcl Augen. 
} 6.0 text {Also zurück zur Natur!
} 7.0 text {
} 8.0 text {Bug in : -- ; --  weil ";" noch { } einsetzt. 
} 9.0 text { 
} 10.0 text { } 11.0

Es war ein Irrtum, bin der "Eleganz" von Tcl erlegen. Ohne {} ist alles einfacher, Compiler und Forthsource. Forth ist einfach! 

Für Tcl Leute ist es ungewohnt. Aber welcher Tcl Mensch will TclForth? Es ist für Forth Leute gemacht. 
- Könnte auch gerade formale Argumente einführen und Substitutionen, wenn mir die {} gefallen... 

Auch die Sourcefiles werden kürzer und lesbarer, wenn auch weniger angenehm für Tcl Augen. 
Also zurück zur Natur!

Bug in : -- ; --  weil ";" noch { } einsetzt.




  0.048 Die Tcl Konsole arbeitet nicht. 

mark insert 1.0 mark current 1.0 text {Muss von Anfang an dabei sein, am besten. In tfMain laden. } 1.0

Muss von Anfang an dabei sein, am besten. In tfMain laden.




  0.049 Chess, Help, 

mark insert 1.0 mark current 1.0 text {Chess Farbe anders. 
} 1.0 text {
} 2.0 text {Helpmenu Forth = DPANS } 3.0

Chess Farbe anders. 

Helpmenu Forth = DPANS




  0.050 kit bilden Version 0.1 








  0.051 Chess View neu 

mark insert 1.0 mark current 1.0 text {? board => square - die Figuren werden auf die Squares verteilt
} 1.0 text {? canvas board - das Spielfeld chessboard besteht aus 64 squares 
} 2.0 text {NEIN die original Namen sind gut gewählt. 
} 3.0 text {? w rausnehmen - nein die Canvas Routinen allgemein lassen. 
} 4.0 text {- Toplevel dazu - OK} 5.0 mark tk::anchor.work.page.panes.t.text 5.20 text {
} 5.20 text { } 6.0

? board => square - die Figuren werden auf die Squares verteilt
? canvas board - das Spielfeld chessboard besteht aus 64 squares 
NEIN die original Namen sind gut gewählt. 
? w rausnehmen - nein die Canvas Routinen allgemein lassen. 
- Toplevel dazu - OK




  0.052 Chess forthitifieren 

mark insert 1.0 mark current 1.0 text {Canvas als objecttype
} 1.0 text {create text => text ohne create, do. polygon, etc.
} 2.0 text {Argumente auf Stack liefern für  Message text, Reihenfolge a la Tk 
} 3.0 text {Reihenfolge korrigieren vor Methodcode (3flip) 
} 4.0 text {tkcanvas w -- damit kann ich jetzt Tcl und Forth Code zusammen anwenden. Bsp. Messages text, rectangle, delete
} 5.0 text {drawChess - Board canvas und frame sofort bilden.
} 6.0 text {bbox liefert eine Liste der Koordinaten - zerlegen mit unlist == join $stack 
} 7.0 text {	join zerlegt auch Strings, ein String ist eine Liste auf dem Stack. } 8.0

Canvas als objecttype
create text => text ohne create, do. polygon, etc.
Argumente auf Stack liefern für  Message text, Reihenfolge a la Tk 
Reihenfolge korrigieren vor Methodcode (3flip) 
tkcanvas w -- damit kann ich jetzt Tcl und Forth Code zusammen anwenden. Bsp. Messages text, rectangle, delete
drawChess - Board canvas und frame sofort bilden.
bbox liefert eine Liste der Koordinaten - zerlegen mit unlist == join $stack 
	join zerlegt auch Strings, ein String ist eine Liste auf dem Stack.




  0.053 Chess ff 

mark insert 1.0 text {- moveTag => canvas move: drawMan, release 
} 1.0 text {- w nicht über Stack geben, weil dann local. w ist globale canvas.
} 2.0 text {- distance macht 	xa xb - xd set  ya yb - yd set -- vereinfacht release . 
} 3.0 text {(- die Figuren bleiben wo ich sie setze, nicht in der Mitte der Box. : tag "current" vergessen) 
} 4.0 text {- canvasfind - overlap (Suchenwirth), laut Tk ist es overlapping - overlap geht auch - w find
} 5.0 text {- w gettags 
} 6.0 text {- w dtag
} 7.0 text {- w addtag
} 8.0 text {- release fertig => Release
} 9.0 text {- White oder "white"? "white". do. "black"} 10.0 mark tk::anchor.work.page.panes.t.text 10.42 text {
} 10.42 text {
} 11.0 text { } 12.0

- moveTag => canvas move: drawMan, release 
- w nicht über Stack geben, weil dann local. w ist globale canvas.
- distance macht 	xa xb - xd set  ya yb - yd set -- vereinfacht release . 
(- die Figuren bleiben wo ich sie setze, nicht in der Mitte der Box. : tag "current" vergessen) 
- canvasfind - overlap (Suchenwirth), laut Tk ist es overlapping - overlap geht auch - w find
- w gettags 
- w dtag
- w addtag
- release fertig => Release
- White oder "white"? "white". do. "black"




  0.054 Chess Bind 

mark insert 1.0 mark current 1.0 text {Unterscheiden: bind $w = widget einbinden und $w bind = etwas im widget einbinden (tag)
} 1.0 text {
} 2.0 text {Commands ohne []: Bsp. BindBoard
} 3.0 text {	"mv <B1-Motion> {%W move current \[expr {%x-\$::X}\] \[expr {%y-\$::Y}\];	set ::X %x; set ::Y %y}" w bindtag
} 4.0 text {	Ist eine Drag Operation, also Wort Drag erfinden.
} 5.0 text {		Rufen:		{push %x; push %y; Drag} - W ist nicht nötig, wir wissen welches Widget es ist.
} 6.0 text {		: Drag ( x y -- )  "current"  x X -  y Y -  w move   x X set  y Y set  ;
} 7.0 text {	Und es funktioniert.
} 8.0 text {
} 9.0 text {Das obligate w auf dem Stack bei StartChess ablegen.} 10.0 mark tk::anchor.work.page.panes.t.text 10.52 text {
} 10.52 text { } 11.0

Unterscheiden: bind $w = widget einbinden und $w bind = etwas im widget einbinden (tag)

Commands ohne []: Bsp. BindBoard
	"mv <B1-Motion> {%W move current \[expr {%x-\$::X}\] \[expr {%y-\$::Y}\];	set ::X %x; set ::Y %y}" w bindtag
	Ist eine Drag Operation, also Wort Drag erfinden.
		Rufen:		{push %x; push %y; Drag} - W ist nicht nötig, wir wissen welches Widget es ist.
		: Drag ( x y -- )  "current"  x X -  y Y -  w move   x X set  y Y set  ;
	Und es funktioniert.

Das obligate w auf dem Stack bei StartChess ablegen.




  0.055 TheBoard = Game Widgets 

mark insert 1.0 mark current 1.0 text {theBoard teilen: Panel p und Canvas w 
} 1.0 text {Panel = Label und Buttons 
} 2.0 text {Und Toplevel Teile zu Chessboard bringen, beim Laden bilden. Kein Colon. 
} 3.0 text {tktoplevel, tkframe, tklabel, tkbutton. } 4.0 tagon b 4.40 text {bringen nichts. } 4.40 tagoff b 4.56 text {Tk Code ist einfacher! } 4.56

theBoard teilen: Panel p und Canvas w 
Panel = Label und Buttons 
Und Toplevel Teile zu Chessboard bringen, beim Laden bilden. Kein Colon. 
tktoplevel, tkframe, tklabel, tkbutton. bringen nichts. Tk Code ist einfacher!




  0.056 Widgets 

mark insert 1.0 mark current 1.0 text {Kann ich in Colon ein Widget bilden? ja. Wird mit uplevel #0 gebildet. 
} 1.0 text {	Muss absolute Windownamen nehmen ".t.f", 	Nicht "$top.f". Aber "$::top.f" ca va!} 2.0 mark tk::anchor.work.page.panes.t.text 2.81 text {
} 2.81 text {Kann ich die Options in einem Colon setzen? ja. Mit den definierten Widgetnamen.
} 3.0 text { } 4.0

Kann ich in Colon ein Widget bilden? ja. Wird mit uplevel #0 gebildet. 
	Muss absolute Windownamen nehmen ".t.f", 	Nicht "$top.f". Aber "$::top.f" ca va!
Kann ich die Options in einem Colon setzen? ja. Mit den definierten Widgetnamen.




  0.057 Chess Stil anpassen 

mark insert 1.0 mark current 1.0 text {wie Chess in Tcl. Gross und Kleinschrift
} 1.0 text {; hinter Text, nicht eigene Zeile -- sehr viel klarer 
} 2.0 text {Canvas und Panel gross, sonst vorwiegend Klein beginnen. 
} 3.0 text {set statt put
} 4.0 mark tk::anchor.work.page.panes.t.text 5.0 text {TclForth Version 0.2
} 5.0 text { } 6.0

wie Chess in Tcl. Gross und Kleinschrift
; hinter Text, nicht eigene Zeile -- sehr viel klarer 
Canvas und Panel gross, sonst vorwiegend Klein beginnen. 
set statt put
TclForth Version 0.2




  0.058 tclkit-0.2 - \<space> 

mark insert 1.0 mark current 1.0 text {Wo wird \ Kommentar erkannt? In EmptyLine - \ muss ein Leerzeichen folgen, sonst nicht erkannt. 
} 1.0 text {tclkit-0.2 und chess-0.2 in GC legen 
} 2.0 text {
} 3.0 text {"." wird ".." } 4.0

Wo wird \ Kommentar erkannt? In EmptyLine - \ muss ein Leerzeichen folgen, sonst nicht erkannt. 
tclkit-0.2 und chess-0.2 in GC legen 

"." wird ".."




  0.059 Compiler und Interpreter - immediate 

mark insert 1.0 mark current 1.0 text {Definer Aktion in LoadUnit und LoadLine separieren als InterpretText.
} 1.0 text {GetSource => GetText.
} 2.0 text {comp(name) = "" setzen in EvalForth, sonst wird es sowieso gesetzt auf den Wortnamen. Gebraucht für Fehlermeldung. 
} 3.0 text {- überflüssig, also comp(name) = "" weglassen. 
} 4.0 text {MakeMacro ist noch HolonT - obsolet. 
} 5.0 text {Leeren Stack mit () angeben. : Leer () "so kann es aussehen" ; 
} 6.0 text {--
} 7.0 text {Wort } 8.0 tagon b 8.5 text immediate 8.5 tagoff b 8.14 text { als Variante von compiler bilden in der Console: 
} 8.14 text {Bsp. 
} 9.0 text {ok> compiler immediate MakeCompiler
} 10.0 text {-- bildet Forthwort immediate = Eintrag immediate in words()
} 11.0 text {
} 12.0 text {ok> immediate if-neu appendcode "if \[pop\]  \{\n"
} 13.0 text {Sorry: appendcode is undefined 
} 14.0 text {-- compiliert die Zeile, ruft dazu die einzelnen Worte:
} 15.0 text {	immediate aktion = MakeCompiler, 
} 16.0 text {		MakeCompiler bildet Forthwort if-neu mit der aktion {appendcode "if \[pop\]  \{\n" }, 
} 17.0 text {		setzt den Zeiger hinter if-neu vor appendcode
} 18.0 text {	appendcode aktion - gibt es nicht weil appendcode kein Forthwort ist - daher Fehlermeldung
} 19.0 text {-- hat aber das Compilerwort if-neu gebildet!
} 20.0 text {
} 21.0 text {ok>: test-neu ( -- ) 10 1 if-neu dup else drop then
} 22.0 text {ok>test-neu
} 23.0 text {10 10 ok> 
} 24.0 text {
} 25.0 text {Einfachere Variante: immediate in die Definers nehmen! } 26.0

Definer Aktion in LoadUnit und LoadLine separieren als InterpretText.
GetSource => GetText.
comp(name) = "" setzen in EvalForth, sonst wird es sowieso gesetzt auf den Wortnamen. Gebraucht für Fehlermeldung. 
- überflüssig, also comp(name) = "" weglassen. 
MakeMacro ist noch HolonT - obsolet. 
Leeren Stack mit () angeben. : Leer () "so kann es aussehen" ; 
--
Wort immediate als Variante von compiler bilden in der Console: 
Bsp. 
ok> compiler immediate MakeCompiler
-- bildet Forthwort immediate = Eintrag immediate in words()

ok> immediate if-neu appendcode "if \[pop\]  \{\n"
Sorry: appendcode is undefined 
-- compiliert die Zeile, ruft dazu die einzelnen Worte:
	immediate aktion = MakeCompiler, 
		MakeCompiler bildet Forthwort if-neu mit der aktion {appendcode "if \[pop\]  \{\n" }, 
		setzt den Zeiger hinter if-neu vor appendcode
	appendcode aktion - gibt es nicht weil appendcode kein Forthwort ist - daher Fehlermeldung
-- hat aber das Compilerwort if-neu gebildet!

ok>: test-neu ( -- ) 10 1 if-neu dup else drop then
ok>test-neu
10 10 ok> 

Einfachere Variante: immediate in die Definers nehmen!




  0.060 Stack diagram leer auch () und (--) 

mark insert 1.0 mark current 1.0 text {CompileStack ergänzt. } 1.0

CompileStack ergänzt.




  0.061 OSX Starpack = APP 

mark insert 1.0 text {Da ich die Sourcefiles extern laden, muss ich aus dem virtuellen Verzeichnis raus zum source Verzeichnis wechseln.
} 1.0 text {Nach viel Experimentieren finde ich folgende Methode in main.tcl in .vfs.
} 2.0 text {
} 3.0 tagon i 4.0 text main.tcl 4.0 tagoff i 4.8 text { } 4.8 tagon i 4.9 text debugversion 4.9 tagoff i 4.21 text {
} 4.21 text {package require starkit
} 5.0 text {starkit::startup
} 6.0 text {# package require Tk   
} 7.0 text {# catch {console show}
} 8.0 text {set dir [file dirname [info script]]  ;# set dir [file dirname $argv0]  geht auch
} 9.0 text {cd $dir                                       ;# erst absolut setzen auf das vfs im Pack
} 10.0 text {cd ../../../../source                     ;# dann relativ aus der App raus zum Source Verzeichnis
} 11.0 text {# puts "Verzeichnis ist [pwd]"
} 12.0 mark current 13.0 text {# tkwait window .
} 13.0 text {source tfmain.tcl
} 14.0 text {
} 15.0 tagon i 16.0 text {main.tcl } 16.0 tagoff i 16.9 text {
} 16.9 text {package require starkit
} 17.0 text {starkit::startup
} 18.0 text {cd [file dirname [info script]]
} 19.0 text {cd ../../../../source
} 20.0 text {source tfmain.tcl
} 21.0 text {
} 22.0 text {
} 23.0 text {Nehme das HolonCode App und modifiziere es. 
} 24.0 text {Editiere die Info.plist, und kriege merkwürdige Resultate. Der Finder ignoriert die Korrekturen. Lädt immer noch holoncode statt tclforth. - Irgendwo im OS muss die erste Version des Bundles gespeichert sein. 
} 25.0 text {=> Für eine Korrektur des Bundles/Paketes eine neue Ausgabe bauen. 
} 26.0 text {Die App ist eine Verzeichnis, das vom Finder als App gezeigt wird. Mit dem Kontextmenu kann ich den Paketinhalt zeigen. Und vielleicht auch korrigieren.
} 27.0 text {
} 28.0 text {Zuerst bin ich im Dunkeln, weiss nicht ob das Starpack überhaupt gerufen wird. 
} 29.0 text {Zur Kontrolle Tk und die Console laden und die aktuelle pwd zeigen.
} 30.0 text {Die pwd ist der root des vfs im Starpack relativ zum root, also / . Ich weiss noch nicht wo das ist relativ zu OSX.} 31.0 mark tk::anchor.work.page.panes.t.text 31.115 text {
} 31.115 text {Das bekommt man mit 
} 32.0 text {set dir [file dirname [info script]] 
} 33.0 text {Von dort aus dann mit cd das Verzeichnis setzen und mit cd ../../../../ vier Stufen hinauf und mit cd ./source eine runter.
} 34.0 text {
} 35.0 text {Gelernt OSX App:
} 36.0 tagon b 37.0 text {Info.plist Korrekturen} 37.0 tagoff b 37.22 text { werden nicht sofort erkannt oder gar nicht. Zur Sicherheit ein neues Bundle bilden.
} 37.22 text {zB wird die Executable file und Icon file Korrektur nicht wirksam.
} 38.0 tagon b 39.0 text {Zeigen was passiert} 39.0 tagoff b 39.19 text {. Tk und Console sofort laden. Puts.
} 39.19 text {
} 40.0 text {
} 41.0 text {
} 42.0 text { } 43.0

Da ich die Sourcefiles extern laden, muss ich aus dem virtuellen Verzeichnis raus zum source Verzeichnis wechseln.
Nach viel Experimentieren finde ich folgende Methode in main.tcl in .vfs.

main.tcl debugversion
package require starkit
starkit::startup
# package require Tk   
# catch {console show}
set dir [file dirname [info script]]  ;# set dir [file dirname $argv0]  geht auch
cd $dir                                       ;# erst absolut setzen auf das vfs im Pack
cd ../../../../source                     ;# dann relativ aus der App raus zum Source Verzeichnis
# puts "Verzeichnis ist [pwd]"
# tkwait window .
source tfmain.tcl

main.tcl 
package require starkit
starkit::startup
cd [file dirname [info script]]
cd ../../../../source
source tfmain.tcl


Nehme das HolonCode App und modifiziere es. 
Editiere die Info.plist, und kriege merkwürdige Resultate. Der Finder ignoriert die Korrekturen. Lädt immer noch holoncode statt tclforth. - Irgendwo im OS muss die erste Version des Bundles gespeichert sein. 
=> Für eine Korrektur des Bundles/Paketes eine neue Ausgabe bauen. 
Die App ist eine Verzeichnis, das vom Finder als App gezeigt wird. Mit dem Kontextmenu kann ich den Paketinhalt zeigen. Und vielleicht auch korrigieren.

Zuerst bin ich im Dunkeln, weiss nicht ob das Starpack überhaupt gerufen wird. 
Zur Kontrolle Tk und die Console laden und die aktuelle pwd zeigen.
Die pwd ist der root des vfs im Starpack relativ zum root, also / . Ich weiss noch nicht wo das ist relativ zu OSX.
Das bekommt man mit 
set dir [file dirname [info script]] 
Von dort aus dann mit cd das Verzeichnis setzen und mit cd ../../../../ vier Stufen hinauf und mit cd ./source eine runter.

Gelernt OSX App:
Info.plist Korrekturen werden nicht sofort erkannt oder gar nicht. Zur Sicherheit ein neues Bundle bilden.
zB wird die Executable file und Icon file Korrektur nicht wirksam.
Zeigen was passiert. Tk und Console sofort laden. Puts.




  0.062 WIN Starpack = EXE 

mark insert 1.0 mark current 1.0 text {Wird komplizierter zum Testen ohne Parallels. Aber ging in zwei Versuchen. } 1.0 mark tk::anchor.work.page.panes.t.text 1.75 text {
} 1.75 text {MakeExe.command  
} 2.0 text {
} 3.0 tagon i 4.0 text main.tcl 4.0 tagoff i 4.8 text {
} 4.8 text {package require starkit
} 5.0 text {starkit::startup
} 6.0 text {cd ../source
} 7.0 text {source tfmain.tcl
} 8.0 text { } 9.0

Wird komplizierter zum Testen ohne Parallels. Aber ging in zwei Versuchen. 
MakeExe.command  

main.tcl
package require starkit
starkit::startup
cd ../source
source tfmain.tcl




  0.063 Files kommentieren 

mark insert 1.0 mark current 1.0 text {Wort Load weglassen. Ist LoadForth oder LoadTcl = source. 
} 1.0 text {openURL ok in Windows? ja} 2.0 mark tk::anchor.work.page.panes.t.text 2.25 text {
} 2.25 text { } 3.0

Wort Load weglassen. Ist LoadForth oder LoadTcl = source. 
openURL ok in Windows? ja




  0.064 Beginn Version 0.4 - Dropbox Migration 

mark insert 1.0 mark current 1.0 text {Worte zeigen: ShowWords => words. } 1.0

Worte zeigen: ShowWords => words.




  0.065 V04, MakeAPP, MakeEXE, SOURCE 

mark insert 1.0 mark current 1.0 text {Interpreterfenster "04" 
} 1.0 text {
} 2.0 text {MakeAPP auf Dropbox korrigieren. 
} 3.0 text {- cd /Users/wolf/Dropbox/Holonforth/HolonTF/Starpack
} 4.0 text {=> neue App ok. 
} 5.0 text {
} 6.0 text {Help/Forth ruft Starting Forth 
} 7.0 text {
} 8.0 text {MakeEXE auf Dropbox korrigieren
} 9.0 text {=> neue Exe ok.
} 10.0 text {
} 11.0 text {MakeSOURCE 
} 12.0 text {=> Copy Sourcefiles zu /SOURCE
} 13.0 text {
} 14.0 text {Kopie von Ordner APP => TclForth-OSX-04 -- Zip => TclForth-OSX-04.zip
} 15.0 text {do. mit EXE => WIN
} 16.0 text {do. SOURCE
} 17.0 text {
} 18.0 text {Test von WIN auf HP Notebook
} 19.0 text {
} 20.0 text {Upload zu GoogleCode: Summary angeben sonst kein Submit möglich} 21.0 mark tk::anchor.work.page.panes.t.text 21.63 text {
} 21.63 text { } 22.0

Interpreterfenster "04" 

MakeAPP auf Dropbox korrigieren. 
- cd /Users/wolf/Dropbox/Holonforth/HolonTF/Starpack
=> neue App ok. 

Help/Forth ruft Starting Forth 

MakeEXE auf Dropbox korrigieren
=> neue Exe ok.

MakeSOURCE 
=> Copy Sourcefiles zu /SOURCE

Kopie von Ordner APP => TclForth-OSX-04 -- Zip => TclForth-OSX-04.zip
do. mit EXE => WIN
do. SOURCE

Test von WIN auf HP Notebook

Upload zu GoogleCode: Summary angeben sonst kein Submit möglich




  0.066 Rev. 0.5 

mark insert 1.0 mark current 1.0 text {Bei einem Fehler den bisher geladenen Code zeigen. } 1.0 mark tk::anchor.work.page.panes.t.text 1.51 text {
} 1.51 text {- Bei Commandline und Sourcefile
} 2.0 text {
} 3.0 text {Bei Eingabe einer Leerzeile (Return zweimal drücken oder so), das Codefenster löschen. 
} 4.0 text {
} 5.0 text {! Die Commandline akzeptiert nur eine Definition, mit Leerzeilen darin. Die Leerzeile ist kein Terminator.
} 6.0 text {- das ist inkonsequent. Leerzeile erfassen.
} 7.0 text { } 8.0

Bei einem Fehler den bisher geladenen Code zeigen. 
- Bei Commandline und Sourcefile

Bei Eingabe einer Leerzeile (Return zweimal drücken oder so), das Codefenster löschen. 

! Die Commandline akzeptiert nur eine Definition, mit Leerzeilen darin. Die Leerzeile ist kein Terminator.
- das ist inkonsequent. Leerzeile erfassen.




  0.501 Rev. 0.5 weiter 

mark insert 1.0 mark current 1.0 text {13.4.2014  } 1.0

13.4.2014




  0.502 div. 

mark insert 1.0 text {okprompt mit Klammern um Stack. Damit eine Ausgabe vom Stack trennen. 
} 1.0 text {--
} 2.0 text {Tk Message: config könnte auch configure sein? also neu definieren als message configure: ja
} 3.0 text {-- fand config wohl kürzer und cooler...? 
} 4.0 text {-- 
} 5.0 text {Console mit Scrollbar wird zu komplex für jetzt.
} 6.0 text {--
} 7.0 text {Fehlermeldung ohne "Sorry:"
} 8.0 text {--
} 9.0 mark tk::anchor.work.page.panes.t.text 10.0 text {
} 10.0 text {
} 11.0 text { } 12.0

okprompt mit Klammern um Stack. Damit eine Ausgabe vom Stack trennen. 
--
Tk Message: config könnte auch configure sein? also neu definieren als message configure: ja
-- fand config wohl kürzer und cooler...? 
-- 
Console mit Scrollbar wird zu komplex für jetzt.
--
Fehlermeldung ohne "Sorry:"
--




  0.503 div. 

mark insert 1.0 mark current 1.0 text {" als Forth Wort weglassen, will einen extra space wenn der String mit einem Space beginnt. 
} 1.0 text {--
} 2.0 text {Tcl Info Help kommt nicht } 3.0

" als Forth Wort weglassen, will einen extra space wenn der String mit einem Space beginnt. 
--
Tcl Info Help kommt nicht




  0.504 Stack mit { -- } 

mark insert 1.0 mark current 1.0 text {Es muss gehen mit {--} weil das macht wirklich Sinn.
} 1.0 text {Deutet an das es Tcl gern hat. 
} 2.0 text {Deutet an dass es Locals sind, das hat Forth200x gern.
} 3.0 text {- CompileStack
} 4.0 text {- Stackdiagramme korrigieren in den .fth Files
} 5.0 text {- Doku korrigieren im Source
} 6.0 text {
} 7.0 text {
} 8.0 text {TEST
} 9.0 text {TclForth 0.4 läuft
} 10.0 text {Lade:  CompileStack in die Tcl-Console. ok
} 11.0 text {Lade:   code !s { -- } set ::stack ""  : ok   die  {} wirken
} 12.0 text {weiter korrigieren -- und es ist gemacht. 30 min.
} 13.0 text {und läuft
} 14.0 text {
} 15.0 text {bei den Objecttypes ist noch ein Problem: can't read "object": no such variable
} 16.0 text {--
} 17.0 text {Locals ansehen: Array locals existiert nach einer Definition die Locals definiert.
} 18.0 text {array exists locals => 1
} 19.0 text {Bsp  { | xx -- }  erzeugt  set locals(xx) variable
} 20.0 text {Ansehen: puts $locals(xx) => variable
} 21.0 text {--
} 22.0 text {ShowWords neu laden:  puts $locals(fw) => list  :: cast funktioniert
} 23.0 text {Nur GetWords rufen: ok
} 24.0 text {und: fw setlist: Fehler
} 25.0 text {0.503 setlist geändert in Speichern bei Index. Warum?  -- jetzt wieder set statt !list -- ok
} 26.0 text {--
} 27.0 text {Was habe ich bei 503 geändert?: nichts mit Listen -- ws eine Tutorialsache, Listen zeigen.
} 28.0 text {--
} 29.0 text {Stackkorrektur zuende bringe: Chess.fth
} 30.0 text {
} 31.0 text {
} 32.0 text {- Setup Menu: Codefenster ein/aus schalten
} 33.0 text {
} 34.0 text {
} 35.0 text {
} 36.0 text {
} 37.0 text { } 38.0

Es muss gehen mit {--} weil das macht wirklich Sinn.
Deutet an das es Tcl gern hat. 
Deutet an dass es Locals sind, das hat Forth200x gern.
- CompileStack
- Stackdiagramme korrigieren in den .fth Files
- Doku korrigieren im Source


TEST
TclForth 0.4 läuft
Lade:  CompileStack in die Tcl-Console. ok
Lade:   code !s { -- } set ::stack ""  : ok   die  {} wirken
weiter korrigieren -- und es ist gemacht. 30 min.
und läuft

bei den Objecttypes ist noch ein Problem: can't read "object": no such variable
--
Locals ansehen: Array locals existiert nach einer Definition die Locals definiert.
array exists locals => 1
Bsp  { | xx -- }  erzeugt  set locals(xx) variable
Ansehen: puts $locals(xx) => variable
--
ShowWords neu laden:  puts $locals(fw) => list  :: cast funktioniert
Nur GetWords rufen: ok
und: fw setlist: Fehler
0.503 setlist geändert in Speichern bei Index. Warum?  -- jetzt wieder set statt !list -- ok
--
Was habe ich bei 503 geändert?: nichts mit Listen -- ws eine Tutorialsache, Listen zeigen.
--
Stackkorrektur zuende bringe: Chess.fth


- Setup Menu: Codefenster ein/aus schalten




  0.505 Labelframes 

mark insert 1.0 mark current 1.0 text {Labels Forth Console, Tcl compiled code 
} 1.0 text {Labels sehen nicht gut aus mit dem Strich durch den Text. Strich weglassen möglich? : -relief flat 
} 2.0 text {=> machbar. Aber ich habe etwas geschafft.  Gefällt nicht, ohne Labels viel cooler.  Nein... Ohne Label magerer. Also mit Labels. Nein doch cooler fahren.
} 3.0 text {Keine Labels und keinen Rahmen für Console, nur für Codewindow.
} 4.0 text { 
} 5.0 text { } 6.0

Labels Forth Console, Tcl compiled code 
Labels sehen nicht gut aus mit dem Strich durch den Text. Strich weglassen möglich? : -relief flat 
=> machbar. Aber ich habe etwas geschafft.  Gefällt nicht, ohne Labels viel cooler.  Nein... Ohne Label magerer. Also mit Labels. Nein doch cooler fahren.
Keine Labels und keinen Rahmen für Console, nur für Codewindow.




  0.506 \-Mystery  OpenURL 

mark insert 1.0 mark current 1.0 text {OpenURL war in V0.4 drin, warum ist es raus und wann und wie??
} 1.0 text {--
} 2.0 text {Warum wird \ am Anfang manchmal nicht akzeptiert, obwohl deutlich ein Leerzeichen folgt.
} 3.0 text {Die Zeichen als ASCII drucken, gesamtes Codefenster.
} 4.0 text {
} 5.0 text proc\ \\-mystery\ \{\}\ \{\n 6.0 text {     set text [$::view(code) get 1.0 end]
} 7.0 text {     set end [string length $text]
} 8.0 text {     set i 0; 
} 9.0 text \ \ \ \ \ while\ \{\$i<\$end\}\ \{\ \n 10.0 text {          set ab [ascii [string index $text $i]] ;
} 11.0 text \ \ \ \ \ \ \ \ \ \ if\ \{\$ab==10\}\ \{\n 12.0 text {               puts $ab
} 13.0 text \ \ \ \ \ \ \ \ \ \ \}\ else\ \{\n 14.0 text {               puts -nonewline "$ab "
} 15.0 text \ \ \ \ \ \ \ \ \ \ \}\n 16.0 text {          incr i;} 17.0 mark tk::anchor.work.page.panes.t.text 17.17 text {
} 17.17 text \ \ \ \ \ \}\ \n 18.0 text {	return;
} 19.0 text \}\ \n 20.0 text {
} 21.0 text {
} 22.0 text {
} 23.0 text {Testtext im Codefenster
} 24.0 text {
} 25.0 text {
} 26.0 text { } 27.0

OpenURL war in V0.4 drin, warum ist es raus und wann und wie??
--
Warum wird \ am Anfang manchmal nicht akzeptiert, obwohl deutlich ein Leerzeichen folgt.
Die Zeichen als ASCII drucken, gesamtes Codefenster.

proc \-mystery {} {
     set text [$::view(code) get 1.0 end]
     set end [string length $text]
     set i 0; 
     while {$i<$end} { 
          set ab [ascii [string index $text $i]] ;
          if {$ab==10} {
               puts $ab
          } else {
               puts -nonewline "$ab "
          }
          incr i;
     } 
	return;
} 



Testtext im Codefenster

\ hallo dies
\ ist 
\ die seite


  0.507 Tk-Widget 

mark insert 1.0 mark current 1.0 text {Generierendes Tk Wort widget - für alle Widget Typen
} 1.0 text {
} 2.0 text {objecttype tkwidget   { type .name -- }
} 3.0 text \ \ \ \ \ instance\ \ \{uplevel\ #0\ \{set\ obj\ \[pop\]\;\ eval\ \[concat\ \[pop\]\ \$obj\]\}\ \n 4.0 text {     {}         {push $obj}
} 5.0 text {     config     {eval $obj [concat configure [pop]]}
} 6.0 text {     set        {eval $obj [concat config [pop]]}
} 7.0 text {     pack       {eval [concat pack $obj [pop]]}
} 8.0 text {     bind       {eval [concat bind $obj [pop]]}
} 9.0 text {	...
} 10.0 text {
} 11.0 text {"text" ".forth" tkwidget Console  ok sobald alle Text Messages drin sind ....
} 12.0 text {--
} 13.0 text {tkcanvas ist speziell.
} 14.0 text {--
} 15.0 text {tkwait ist interner tk-Command, Message wait
} 16.0 text {--
} 17.0 text {HideTclConsole:  console hide
} 18.0 text {uvm
} 19.0 text { } 20.0

Generierendes Tk Wort widget - für alle Widget Typen

objecttype tkwidget   { type .name -- }
     instance  {uplevel #0 {set obj [pop]; eval [concat [pop] $obj]} 
     {}         {push $obj}
     config     {eval $obj [concat configure [pop]]}
     set        {eval $obj [concat config [pop]]}
     pack       {eval [concat pack $obj [pop]]}
     bind       {eval [concat bind $obj [pop]]}
	...

"text" ".forth" tkwidget Console  ok sobald alle Text Messages drin sind ....
--
tkcanvas ist speziell.
--
tkwait ist interner tk-Command, Message wait
--
HideTclConsole:  console hide
uvm




  0.508 div. 

mark insert 1.0 mark current 1.0 text {drop korrigiert
} 1.0 text {sqrt neu
} 2.0 text {alias neu
} 3.0 text {!S CC
} 4.0 text {--
} 5.0 text {warum cast nur locals? macht Sinn, weil locals immer erst 'variable' sind.
} 6.0 text {--
} 7.0 text {ok> lassen, ok allein wirkt nicht - oder? nein: ok ist elegant -- aber ok> ist besser erkennbar in der Console!!} 8.0 mark tk::anchor.work.page.panes.t.text 8.112 text {
} 8.112 text {--
} 9.0 text {doi,j,k sind global aber keine Forthworte.
} 10.0 text {do loops können geschachtelt sein in anderen Worten, funktionieren trotzdem.
} 11.0 text {Verstehe nicht mehr warum...
} 12.0 text {--
} 13.0 text {
} 14.0 text { } 15.0

drop korrigiert
sqrt neu
alias neu
!S CC
--
warum cast nur locals? macht Sinn, weil locals immer erst 'variable' sind.
--
ok> lassen, ok allein wirkt nicht - oder? nein: ok ist elegant -- aber ok> ist besser erkennbar in der Console!!
--
doi,j,k sind global aber keine Forthworte.
do loops können geschachtelt sein in anderen Worten, funktionieren trotzdem.
Verstehe nicht mehr warum...
--




  0.509 Console in Forth 

mark insert 1.0 mark current 1.0 text {Eigentlich sollte die Console voll in Forth definiert sein. Als Beispiel. Und Vorbild.
} 1.0 text {--
} 2.0 text {end-code könnte helfen,   ';'  do.
} 3.0 text {--
} 4.0 text {Menus später ...
} 5.0 text {
} 6.0 mark tk::anchor.work.page.panes.t.text 7.0 text {Print muss prefix bleiben, oder viel grübeln in den Tcl Befehlen. } 7.0

Eigentlich sollte die Console voll in Forth definiert sein. Als Beispiel. Und Vorbild.
--
end-code könnte helfen,   ';'  do.
--
Menus später ...

Print muss prefix bleiben, oder viel grübeln in den Tcl Befehlen.




  0.510 Menus 

mark tk::anchor.work.page.panes.t.text 1.0 mark insert 1.0 mark current 1.0 text {widget tkMenu name 
} 1.0 text {
} 2.0 text {".tkname" tkmenu menu
} 3.0 text {"command" "script" menu addcommand
} 4.0 text {"label" "menu" "menubar" addmenu 
} 5.0 text { } 6.0

widget tkMenu name 

".tkname" tkmenu menu
"command" "script" menu addcommand
"label" "menu" "menubar" addmenu




  0.511 tkwidgets => Widget 

mark insert 1.0 mark current 1.0 text {Reihenfolge der Argumente umkehren. Typ vor tkwidget.
} 1.0 text {
} 2.0 text {".forth" "text" tkwidget Console
} 3.0 text {
} 4.0 text {"$::top.f" "frame" tkwidget frame 
} 5.0 text {
} 6.0 text {".t" "toplevel" tkwidget top
} 7.0 text {
} 8.0 text {--
} 9.0 text {
} 10.0 text {TF widgets = Grossbuchstabe:  Widget  Menu  Canvas
} 11.0 text {
} 12.0 text {
} 13.0 text { } 14.0

Reihenfolge der Argumente umkehren. Typ vor tkwidget.

".forth" "text" tkwidget Console

"$::top.f" "frame" tkwidget frame 

".t" "toplevel" tkwidget top

--

TF widgets = Grossbuchstabe:  Widget  Menu  Canvas




  0.512 Typen in Grossschrift? Nein 

mark insert 1.0 mark current 1.0 text {Wie die Widgets auch alle Typen grossschreiben als Forth Worte
} 1.0 text {Kontrast zu Tcl Typen.
} 2.0 text { 
} 3.0 text {compiler => Compiler - ok
} 4.0 text {! TF akzeptiert beides, grosser und kleiner Anfangsbuchstaben.  mit "tolower"
} 5.0 text {
} 6.0 text {Alle Definer Gross oder klein akzeptiert. Mache sie Gross im Source.
} 7.0 text {
} 8.0 text {- HideTclConsole weg, Tcl console garnicht erst laden. - Doch. Muss console am Anfang laden, sonst funktioniert sie später nicht. (Warum ???)
} 9.0 text {
} 10.0 text {- code => Code - ok 
} 11.0 text {- objecttype => Objecttype - ok
} 12.0 text {
} 13.0 text {- variable => Variable => variable} 14.0 mark tk::anchor.work.page.panes.t.text 14.34 text {
} 14.34 text {Entweder oder.  variable ist nicht mehr dabei. Wie ist es bei den Locals? ??
} 15.0 text {Nein: Typen bleiben in Kleinschrift.
} 16.0 text {
} 17.0 text {
} 18.0 text { } 19.0

Wie die Widgets auch alle Typen grossschreiben als Forth Worte
Kontrast zu Tcl Typen.
 
compiler => Compiler - ok
! TF akzeptiert beides, grosser und kleiner Anfangsbuchstaben.  mit "tolower"

Alle Definer Gross oder klein akzeptiert. Mache sie Gross im Source.

- HideTclConsole weg, Tcl console garnicht erst laden. - Doch. Muss console am Anfang laden, sonst funktioniert sie später nicht. (Warum ???)

- code => Code - ok 
- objecttype => Objecttype - ok

- variable => Variable => variable
Entweder oder.  variable ist nicht mehr dabei. Wie ist es bei den Locals? ??
Nein: Typen bleiben in Kleinschrift.




  0.513 Source beenden 

mark insert 1.0 mark current 1.0 text {Widget2 anwenden, Widget instantiieren inklusive Configuration, wie Tk. - Nein. Es ist genug.
} 1.0 text {--
} 2.0 text {Source einpacken und Systeme bilden. } 3.0

Widget2 anwenden, Widget instantiieren inklusive Configuration, wie Tk. - Nein. Es ist genug.
--
Source einpacken und Systeme bilden.




  0.514 Update 0.51... 

mark insert 1.0 mark current 1.0 text {ok> mit space, sieht einfach sauberer aus.
} 1.0 text {Aber die Leute wollen es wahrscheinlich 
} 2.0 text {(88) ok hier beginnen
} 3.0 text {ok>zeigt hier den Anfang
} 4.0 text {also ok und space oder ok>und kein space 
} 5.0 text {--> ok> und space, aber der Befehl kann direkt hinter ok> beginnen.
} 6.0 text {--
} 7.0 text {nehme die Zeile ab ok> und trimme Leerraum beidseitig weg (das bisher schon).
} 8.0 text {Die alten command lines werden immer nach dem Space gesetzt weil prompt "ok> " schreibt.
} 9.0 text {--
} 10.0 text {So geht es.
} 11.0 text {--
} 12.0 text {(update test)} 13.0 mark tk::anchor.work.page.panes.t.text 13.13 text {
} 13.13 text { } 14.0

ok> mit space, sieht einfach sauberer aus.
Aber die Leute wollen es wahrscheinlich 
(88) ok hier beginnen
ok>zeigt hier den Anfang
also ok und space oder ok>und kein space 
--> ok> und space, aber der Befehl kann direkt hinter ok> beginnen.
--
nehme die Zeile ab ok> und trimme Leerraum beidseitig weg (das bisher schon).
Die alten command lines werden immer nach dem Space gesetzt weil prompt "ok> " schreibt.
--
So geht es.
--
(update test)




  0.515 Testcommit 

mark insert 1.0 mark current 1.0 text {Jetzt sollte die vorige Version = Revision in Dropbox gespeichert sein als Backup. Ist aber nicht.
} 1.0 text {=> Die hdb-Datei muss voll geschlossen werden, damit Dropbox sie akzeptiert } 2.0

Jetzt sollte die vorige Version = Revision in Dropbox gespeichert sein als Backup. Ist aber nicht.
=> Die hdb-Datei muss voll geschlossen werden, damit Dropbox sie akzeptiert




  0.516 Linux Version 

mark insert 1.0 text {Der Source lädt nicht aus dem Terminal wegen 'show console'.
} 1.0 text {console Befehle alle catchen! 
} 2.0 text {--
} 3.0 text {SetupMenu hatte zweimal Open Tcl console.
} 4.0 text {--
} 5.0 text {TF in Linux laufen lassen aus dem Terminal funktioniert wenn das Terminal verschwindet bevor TF den Source lädt.
} 6.0 text {Und das geht mit nohup und exit,  wenn tclkit85 auch im Source liegt.
} 7.0 text {
} 8.0 text {cd ---/TclForth-Source-05
} 9.0 text {nohup ./tclkit85 tfmain.tcl & exit
} 10.0 text {
} 11.0 text { } 12.0

Der Source lädt nicht aus dem Terminal wegen 'show console'.
console Befehle alle catchen! 
--
SetupMenu hatte zweimal Open Tcl console.
--
TF in Linux laufen lassen aus dem Terminal funktioniert wenn das Terminal verschwindet bevor TF den Source lädt.
Und das geht mit nohup und exit,  wenn tclkit85 auch im Source liegt.

cd ---/TclForth-Source-05
nohup ./tclkit85 tfmain.tcl & exit




  0.517 Bug in ShowWords 

mark insert 1.0 mark current 1.0 text {ShowWords hat ein pop zuviel.
} 1.0 text {Grund: list join - wurde 0.514 geändert in   {set obj [join $obj [pop]]} -- warum? ws weil join 2 Argumente hat (optional)} 2.0 mark tk::anchor.work.page.panes.t.text 2.122 text {
} 2.122 text {! Es hat nur ShowWords betroffen, der Rest funktioniert. } 3.0

ShowWords hat ein pop zuviel.
Grund: list join - wurde 0.514 geändert in   {set obj [join $obj [pop]]} -- warum? ws weil join 2 Argumente hat (optional)
! Es hat nur ShowWords betroffen, der Rest funktioniert.




  0.518 Bugs 

mark insert 1.0 mark current 1.0 text {asciiOf  
} 1.0 text {ruft das TF ascii, muss also den Text auf dem Stack liefern.
} 2.0 text {--
} 3.0 text {."  
} 4.0 text {PushText  appendcode "print \[pop\] ; " 
} 5.0 text { ." 888"  
} 6.0 text {? wrong # args: should be "PushText" (ohne Argumente) 
} 7.0 text {es fehlt ein ; hinter Pushtext.  => Compiler ."  PushText ; appendcode "printnl \[pop\] ; " 
} 8.0 text {und mit printnl - man will ja eine neue Zeile.
} 9.0 text {-- 
} 10.0 text {Neue Version 052 -- In ConsoleWindows ändern
} 11.0 text {-- 
} 12.0 text {HolonTF jetzt in neuem Repo holonforth/tclforth. } 13.0

asciiOf  
ruft das TF ascii, muss also den Text auf dem Stack liefern.
--
."  
PushText  appendcode "print \[pop\] ; " 
 ." 888"  
? wrong # args: should be "PushText" (ohne Argumente) 
es fehlt ein ; hinter Pushtext.  => Compiler ."  PushText ; appendcode "printnl \[pop\] ; " 
und mit printnl - man will ja eine neue Zeile.
-- 
Neue Version 052 -- In ConsoleWindows ändern
-- 
HolonTF jetzt in neuem Repo holonforth/tclforth.




  0.519 Updates 

mark insert 1.0 mark current 1.0 text {Update: Wort % => mod
} 1.0 text {--
} 2.0 text {[ und ] sind noch nicht definiert.
} 3.0 text {-- } 4.0

Update: Wort % => mod
--
[ und ] sind noch nicht definiert.
--




  0.520 Neue Rev nach Commit und Sync 

mark insert 1.0 mark current 1.0 text {eine korrekur für den neuen git test 13.10.2014 } 1.0

eine korrekur für den neuen git test 13.10.2014




  0.521 HolonTF mit Git-Repo vereinigt 

mark insert 1.0 mark current 1.0 text {Github ist genial. Mit dem passenden .gitignore kommt nur das ins remote Git was dort sein soll.} 1.0 mark tk::anchor.work.page.panes.t.text 1.96 text {
} 1.96 text {
} 2.0 text { } 3.0

Github ist genial. Mit dem passenden .gitignore kommt nur das ins remote Git was dort sein soll.




  0.522 Vorbereiten für GitHub 0.55 + 

mark insert 1.0 mark current 1.0 text {Menu: Import -> Load 
} 1.0 text {Stack immer zeigen in Commandline, oder doch nicht. Wählbar.
} 2.0 text {Console-Worte als Package benennen: consoleShow ? vorerst nicht.
} 3.0 text {tclforth.command fehlt, ist nicht in git Repo mitgekommen, eingesetzt 
} 4.0 text {.gitignore ergänzt 
} 5.0 text {--
} 6.0 text {Version: 0.55 vorläufig 
} 7.0 text {--
} 8.0 text {ForthConsole ohne Console wait !!!! - dann wird die Tcl Console nicht blockiert - ich Aff ... 
} 9.0 text {--
} 10.0 text {Help Menu: TclForth Words, Tcl Commands 
} 11.0 text {--
} 12.0 text {weiter geändert nach commit als 0.55 - beachten bei späterer Archeologie. 
} 13.0 text {(alles in Fluss bis 0.6 offizielle Version. 0.55 ist greifbar aber so what, 0.6 wird kompatibel sein, vielleicht, wen kümmerts?)} 14.0 mark tk::anchor.work.page.panes.t.text 14.128 text { } 14.128

Menu: Import -> Load 
Stack immer zeigen in Commandline, oder doch nicht. Wählbar.
Console-Worte als Package benennen: consoleShow ? vorerst nicht.
tclforth.command fehlt, ist nicht in git Repo mitgekommen, eingesetzt 
.gitignore ergänzt 
--
Version: 0.55 vorläufig 
--
ForthConsole ohne Console wait !!!! - dann wird die Tcl Console nicht blockiert - ich Aff ... 
--
Help Menu: TclForth Words, Tcl Commands 
--
weiter geändert nach commit als 0.55 - beachten bei späterer Archeologie. 
(alles in Fluss bis 0.6 offizielle Version. 0.55 ist greifbar aber so what, 0.6 wird kompatibel sein, vielleicht, wen kümmerts?)




  0.523 => 551 

mark insert 1.0 mark current 1.0 text {weiter zu 552 } 1.0

weiter zu 552




  0.552 STATE 

mark insert 1.0 mark current 1.0 text {Immediate Aktion in der Command line bedingt State. Es geht nicht ohne. Jedoch wird auch der immediate Teil compiliert und dann ausgeführt. 
} 1.0 text {Wenn comp(state)=0, code in comp(icode) sammeln. 
} 2.0 text {--
} 3.0 text {Funktioniert nicht, und idt auch nicht notwendig.
} 4.0 text {=> aufgeben, [ ] herausnehmen. 
} 5.0 text {Ohne STATE arbeiten.
} 6.0 text { } 7.0

Immediate Aktion in der Command line bedingt State. Es geht nicht ohne. Jedoch wird auch der immediate Teil compiliert und dann ausgeführt. 
Wenn comp(state)=0, code in comp(icode) sammeln. 
--
Funktioniert nicht, und idt auch nicht notwendig.
=> aufgeben, [ ] herausnehmen. 
Ohne STATE arbeiten.




  0.553 ohne STATE, nur [ und ] 

mark insert 1.0 mark current 1.0 text {State Versuch beendet. Zurücksetzen:
} 1.0 text {LoadLine 
} 2.0 text {ji ij (waren [ ]) löschen
} 3.0 text {comp(x) comp(state) comp(icode) löschen
} 4.0 text {appendcode 
} 5.0 text {--
} 6.0 text {und dann kommt die gute idee
} 7.0 text {und es ergibt sich.
} 8.0 text {Ohne STATE aber mit [ und ] } 9.0

State Versuch beendet. Zurücksetzen:
LoadLine 
ji ij (waren [ ]) löschen
comp(x) comp(state) comp(icode) löschen
appendcode 
--
und dann kommt die gute idee
und es ergibt sich.
Ohne STATE aber mit [ und ]




  0.56 GH Commit 

mark tk::anchor.work.page.panes.t.text 1.0 mark insert 1.0 mark current 1.0 text {Prozedere:
} 1.0 text {Version = 0.559
} 2.0 text {Commit => 0.560
} 3.0 text {File headers anpassen
} 4.0 text {Console Fenster anpassen
} 5.0 text {Zu GH senden
} 6.0 text {--
} 7.0 text {Commit Summary:
} 8.0 text {Version 0.56
} 9.0 text {Description:
} 10.0 text {Changes:
} 11.0 text {- Menus
} 12.0 text {- Tcl Console unblocked in terminal
} 13.0 text {- list join, ." correct
} 14.0 text {- % => mod 
} 15.0 text {- immediate action on command line [ ]
} 16.0 text {
} 17.0 text { } 18.0

Prozedere:
Version = 0.559
Commit => 0.560
File headers anpassen
Console Fenster anpassen
Zu GH senden
--
Commit Summary:
Version 0.56
Description:
Changes:
- Menus
- Tcl Console unblocked in terminal
- list join, ." correct
- % => mod 
- immediate action on command line [ ]




  0.561 [ ] u.a. 

mark insert 1.0 mark current 1.0 text {forth.fth mit [ und ] commited als 0.561 
} 1.0 text -- 2.0 mark tk::anchor.work.page.panes.t.text 2.2 text {
} 2.2 text {forth.fth ." ohne newline } 3.0

forth.fth mit [ und ] commited als 0.561 
--
forth.fth ." ohne newline




  0.562 updates 

mark insert 1.0 mark current 1.0 text {HelpMenu zeigt auf GitHub Wiki 
} 1.0 text {Tour: helpMenu => hMenu , u.a. 
} 2.0 text {Console ganz sec: ohne Shortcuts Liste } 3.0 mark tk::anchor.work.page.panes.t.text 3.39 text {aber mit anderem Text über TF } 3.39

HelpMenu zeigt auf GitHub Wiki 
Tour: helpMenu => hMenu , u.a. 
Console ganz sec: ohne Shortcuts Liste aber mit anderem Text über TF




  0.563 Multiunits Console input 

mark insert 1.0 mark current 1.0 text {Leerzeilen in Consolentext soll Units/Definitionen/Zeilen beenden. Wie in Sourcefiles.
} 1.0 text {--
} 2.0 text {LoadFile und EvalText von Console kombinieren. 
} 3.0 text {LoadUnit kann gleich sein, wenn der Text der Unit in comp(text), (in) und (end) liegt. - 
} 4.0 text {Refactor LoadForth:
} 5.0 text {- LoadUnit von GetText befreien. ok
} 6.0 text {--
} 7.0 text {EvalText erweitern: 
} 8.0 text {- GetLine ist nicht anwendbar, weil das Ende der Line(s) durch den Insertcursor bestimmt ist.
} 9.0 text {- Den ganzen Text übernehmen, dann in Units zerlegen.
} 10.0 text {- Initteil von GetLine zu LoadLine zu Load Unit zu InterpretText zu SetupInterpreter geschoben	 
} 11.0 text {--
} 12.0 text {EvalUnit einführen, Zeilen mit \n joinen.
} 13.0 text {--
} 14.0 text {Zeilen mit Zahlen und Forthworten funktionieren, Leerzeile schliesst ab. ok.
} 15.0 text {--
} 16.0 text {Codefenster: löschen vor EvalText, Code sammeln für alle Units 
} 17.0 text {Unit in History speichern
} 18.0 text {--
} 19.0 text {join => append -- join hat ein Problem mit { und } im Code weil dies auch Trennzeichen für die Liste sind. 
} 20.0 text {append unit \n $zeile 
} 21.0 text {- \n vor der $zeile einsetzen, sonst hat in GetItem die regexp ein leeres 'range' durch das trailing \n. -- Fehlermeldung: no variable range , oder so.
} 22.0 text {--
} 23.0 text {lädt eine lange Codedefinition, scheint ok. } 24.0 mark tk::anchor.work.page.panes.t.text 24.44 text {
} 24.44 text {Lädt die Tk App Codes, mehrere Worte zusammen. ok. } 25.0

Leerzeilen in Consolentext soll Units/Definitionen/Zeilen beenden. Wie in Sourcefiles.
--
LoadFile und EvalText von Console kombinieren. 
LoadUnit kann gleich sein, wenn der Text der Unit in comp(text), (in) und (end) liegt. - 
Refactor LoadForth:
- LoadUnit von GetText befreien. ok
--
EvalText erweitern: 
- GetLine ist nicht anwendbar, weil das Ende der Line(s) durch den Insertcursor bestimmt ist.
- Den ganzen Text übernehmen, dann in Units zerlegen.
- Initteil von GetLine zu LoadLine zu Load Unit zu InterpretText zu SetupInterpreter geschoben	 
--
EvalUnit einführen, Zeilen mit \n joinen.
--
Zeilen mit Zahlen und Forthworten funktionieren, Leerzeile schliesst ab. ok.
--
Codefenster: löschen vor EvalText, Code sammeln für alle Units 
Unit in History speichern
--
join => append -- join hat ein Problem mit { und } im Code weil dies auch Trennzeichen für die Liste sind. 
append unit \n $zeile 
- \n vor der $zeile einsetzen, sonst hat in GetItem die regexp ein leeres 'range' durch das trailing \n. -- Fehlermeldung: no variable range , oder so.
--
lädt eine lange Codedefinition, scheint ok. 
Lädt die Tk App Codes, mehrere Worte zusammen. ok.




  0.564 EvalText putzen 

mark insert 1.0 mark current 1.0 text {ShowCompCode mit Leerzeile - oder \n - zwischen Units.
} 1.0 text {In EvalUnit nochmal Leerzeichen vorne und hinten abschneiden, trimmen.
} 2.0 text {EvalUnit nicht auf neuen Zeilen beginnen, wenn Units neue Zeile wollen für Ausgabe können sie es selber machen.
} 3.0 text {EvalText beginnt auf neuer Zeile.} 4.0 mark tk::anchor.work.page.panes.t.text 4.33 text {
} 4.33 text { } 5.0

ShowCompCode mit Leerzeile - oder \n - zwischen Units.
In EvalUnit nochmal Leerzeichen vorne und hinten abschneiden, trimmen.
EvalUnit nicht auf neuen Zeilen beginnen, wenn Units neue Zeile wollen für Ausgabe können sie es selber machen.
EvalText beginnt auf neuer Zeile.




  0.565 String range, Console end, <ok> 

mark insert 1.0 mark current 1.0 text {String mit command/message/method range.
} 1.0 text {--
} 2.0 text {Exp. mit ok> & \n - also Befehl auf neuer Zeile eingeben. -> Arbeit! 
} 3.0 text {In Textwidget ist end bezogen auf den Text effektiv "end -1 char".
} 4.0 text {Wenn Tk Text end gelöscht wird, geht end auf die vorige Zeile.
} 5.0 text {Klassische Version mit <ok> gefällt. Ist weniger dicht als bisher, dafür ist das Geschehen sauber dokumentiert. Leere Zeilen sind leer.
} 6.0 text {Anfangs-ok mit cr. 
} 7.0 text {=> Change: <ok> auf eigener Zeile } 8.0

String mit command/message/method range.
--
Exp. mit ok> & \n - also Befehl auf neuer Zeile eingeben. -> Arbeit! 
In Textwidget ist end bezogen auf den Text effektiv "end -1 char".
Wenn Tk Text end gelöscht wird, geht end auf die vorige Zeile.
Klassische Version mit <ok> gefällt. Ist weniger dicht als bisher, dafür ist das Geschehen sauber dokumentiert. Leere Zeilen sind leer.
Anfangs-ok mit cr. 
=> Change: <ok> auf eigener Zeile




  0.566 dummy nicht benutzt 








  0.567 GetItem Bug: "Can't read range" 

mark insert 1.0 mark current 1.0 text {GetItem holt ein Wort als Text zwischen Leerraum. Leerraum ist Space und NewLine und Tab.
} 1.0 text {Beim Kopieren aus Evernote können noch andere nicht sichtbare Zeichen in der Zeile sein, und das gibt den Fehler
} 2.0 tagon b 3.0 text {"? can't read "range": no such variable"
} 3.0 tagoff b 4.0 text {Dies kommt bei normalen Programmeditoren kaum vor, dennoch ist es ein Grund für mögliche Probleme.
} 4.0 text {E: Auf Leerraum testen als "Nicht-Sichtbare-erlaubte -Zeichen". Also Nicht:A-Za-z0-9:;,. usw. ASCII>31 UND <126
} 5.0 text {=> regexp studieren. -- nein, zu komplex.
} 6.0 text {--
} 7.0 text {E: reg=0 testen (kein match gefunden) => comp(word)="" zurückgeben
} 8.0 text {
} 9.0 text proc\ GetItem\ \{\}\ \{\n 10.0 text {	global comp
} 11.0 text {	if {$comp(i)>=$comp(end)} {set comp(word) "" ; return $comp(word)}
} 12.0 text {	set reg [regexp -indices -start $comp(i)  {\S+} $comp(text) range]
} 13.0 text {if $reg==0 {set comp(word) "", return $comp(word)} 
} 14.0 text {	set start [lindex $range 0]
} 15.0 text {	set end [lindex $range 1]
} 16.0 text {	set comp(word) [string range $comp(text) $start $end ] 
} 17.0 text {	set comp(prev) $start
} 18.0 text {	incr end; 	set comp(i) $end
} 19.0 text {	if {$comp(word)=="."} {set comp(word) ".."}} 20.0 mark tk::anchor.work.page.panes.t.text 20.44 text {
} 20.44 text {	return $comp(word)
} 21.0 text \}\n 22.0 text {Das hilft nicht. Evernote setzt merkwürdige Zeichen ein weil es die Seite mit HTML schreibt und bei Copy irgendwie HTML Zeichen drin bleiben. Dagger (Kreuze) habe ich mal gesehen. - Aber wer editiert Programmcode in EN. Ausser mir?? 
} 23.0 tagon b 24.0 text {=> diesen Bug ignorieren weil es ist kein TF Bug. Bis jemand wirklich Probleme hat.} 24.0 tagoff b 24.83 text {
} 24.83 text {
} 25.0 text {> Unter Debug in Wiki notieren.
} 26.0 text {
} 27.0 text { } 28.0

GetItem holt ein Wort als Text zwischen Leerraum. Leerraum ist Space und NewLine und Tab.
Beim Kopieren aus Evernote können noch andere nicht sichtbare Zeichen in der Zeile sein, und das gibt den Fehler
"? can't read "range": no such variable"
Dies kommt bei normalen Programmeditoren kaum vor, dennoch ist es ein Grund für mögliche Probleme.
E: Auf Leerraum testen als "Nicht-Sichtbare-erlaubte -Zeichen". Also Nicht:A-Za-z0-9:;,. usw. ASCII>31 UND <126
=> regexp studieren. -- nein, zu komplex.
--
E: reg=0 testen (kein match gefunden) => comp(word)="" zurückgeben

proc GetItem {} {
	global comp
	if {$comp(i)>=$comp(end)} {set comp(word) "" ; return $comp(word)}
	set reg [regexp -indices -start $comp(i)  {\S+} $comp(text) range]
if $reg==0 {set comp(word) "", return $comp(word)} 
	set start [lindex $range 0]
	set end [lindex $range 1]
	set comp(word) [string range $comp(text) $start $end ] 
	set comp(prev) $start
	incr end; 	set comp(i) $end
	if {$comp(word)=="."} {set comp(word) ".."}
	return $comp(word)
}
Das hilft nicht. Evernote setzt merkwürdige Zeichen ein weil es die Seite mit HTML schreibt und bei Copy irgendwie HTML Zeichen drin bleiben. Dagger (Kreuze) habe ich mal gesehen. - Aber wer editiert Programmcode in EN. Ausser mir?? 
=> diesen Bug ignorieren weil es ist kein TF Bug. Bis jemand wirklich Probleme hat.

> Unter Debug in Wiki notieren.




  0.568 okprompt 

mark insert 1.0 mark current 1.0 text {<ok> wird } 1.0 mark tk::anchor.work.page.panes.t.text 1.10 text {"ok", dann ist klar dass der Befehl nicht direkt danach folgt. 
} 1.10 text {--
} 2.0 text {Leerzeilen vermeiden. Wenn die Befehlszeile leer ist, ok hier schreiben ohne Zeilenvorschub.
} 3.0 text {Das sieht sauber aus und geht sparsam um mit dem Konsolenplatz } 4.0

<ok> wird "ok", dann ist klar dass der Befehl nicht direkt danach folgt. 
--
Leerzeilen vermeiden. Wenn die Befehlszeile leer ist, ok hier schreiben ohne Zeilenvorschub.
Das sieht sauber aus und geht sparsam um mit dem Konsolenplatz




  0.569 div. / Monitor 

mark insert 1.0 mark current 1.0 text {list print ohne cr - nein print ist mit cr 
} 1.0 text {--
} 2.0 text {Der Monitor von Holon funktioniert auch in TF mit dem Unterschied:
} 3.0 text {- source => LoadForth, weil wir ja Forth code verarbeiten wollen.
} 4.0 text {noch feintunen, wo soll was geschehen?
} 5.0 text {- In Commandline kopieren und ausführen? ja: LoadInConsole
} 6.0 text {das funktioniert. Noch mit HolonU verbinden und publizieren. Später.} 7.0 mark tk::anchor.work.page.panes.t.text 7.68 text {
} 7.68 text {
} 8.0 text { } 9.0

list print ohne cr - nein print ist mit cr 
--
Der Monitor von Holon funktioniert auch in TF mit dem Unterschied:
- source => LoadForth, weil wir ja Forth code verarbeiten wollen.
noch feintunen, wo soll was geschehen?
- In Commandline kopieren und ausführen? ja: LoadInConsole
das funktioniert. Noch mit HolonU verbinden und publizieren. Später.




  0.570 Version 0.6.0 

mark insert 1.0 text {Prozedere:
} 1.0 text {Version = 0.570
} 2.0 text {Commit => 0.600   offiziell v0.6.0
} 3.0 text {File headers anpassen
} 4.0 text {Console Fenster anpassen
} 5.0 text {Zu GH senden
} 6.0 text {--
} 7.0 text {Commit Summary:
} 8.0 text {Version 0.6.0
} 9.0 text {Description:
} 10.0 text {Changes:
} 11.0 text {- Autonomous apps (Starpacks)
} 12.0 text {-  
} 13.0 mark tk::anchor.work.page.panes.t.text 14.0 text {
} 14.0 text {--
} 15.0 text {Status von GH holen! } 16.0

Prozedere:
Version = 0.570
Commit => 0.600   offiziell v0.6.0
File headers anpassen
Console Fenster anpassen
Zu GH senden
--
Commit Summary:
Version 0.6.0
Description:
Changes:
- Autonomous apps (Starpacks)
-  

--
Status von GH holen!




  0.571 Monitor Sachen 

mark insert 1.0 mark current 1.0 text {Bei Eingaben von holon.mon gibt es zwei zusätzliche Leerzeilen, die ich nicht orten kann.
} 1.0 text {Vielleicht hängt es mit uplevel #0 in doit zusammen? 
} 2.0 text {So what? Nehmen wir es als ein Signal dass wir hier remote arbeiten. 
} 3.0 text {--
} 4.0 text {Der Stand der Dinge, 061:
} 5.0 text {
} 6.0 text {TclForth061 greift auf holon.mon zu im selben Verzeichnis
} 7.0 text { |- TclForth061.app
} 8.0 text { |- holon.mon
} 9.0 text {
} 10.0 text {Remote steuern mit HolonU: HolonU = holon-osx  schreibt in holon-osx/source/holon.mon
} 11.0 text {=> TclForth061 in Holonu/source legen,
} 12.0 text {also 
} 13.0 text {/holon-osx/source/TclForth061.app
} 14.0 text {
} 15.0 text {Do. mit .exe - testen: 
} 16.0 text {als /holon-win/source/tclforth061.app abgelegt 
} 17.0 text {
} 18.0 text { } 19.0

Bei Eingaben von holon.mon gibt es zwei zusätzliche Leerzeilen, die ich nicht orten kann.
Vielleicht hängt es mit uplevel #0 in doit zusammen? 
So what? Nehmen wir es als ein Signal dass wir hier remote arbeiten. 
--
Der Stand der Dinge, 061:

TclForth061 greift auf holon.mon zu im selben Verzeichnis
 |- TclForth061.app
 |- holon.mon

Remote steuern mit HolonU: HolonU = holon-osx  schreibt in holon-osx/source/holon.mon
=> TclForth061 in Holonu/source legen,
also 
/holon-osx/source/TclForth061.app

Do. mit .exe - testen: 
als /holon-win/source/tclforth061.app abgelegt




  0.572 GetItem debuggen 

mark insert 1.0 mark current 1.0 text {Der alte Fehler "Can't read range: no such variable".
} 1.0 text {Es können nicht-space Zeichen im Leerraum sein. 
} 2.0 text {- nicht nach space suchen sondern nacht non-printable chars.
} 3.0 text {
} 4.0 text {regexp -indices -start $comp(i)  {\S+} $comp(text) range
} 5.0 text {
} 6.0 text {\S+ sucht den folgenden Leerraum (space, tab, cr)
} 7.0 text {
} 8.0 text {Testsource momentane Array Definition, aus EN kopiert: hat im Leerraum etwas das man nicht sieht, das aber auch kein \S+ ist.
} 9.0 text {
} 10.0 text {E1: regexp = 0  setzt error "not found"  mit letztem erfassten Wort im source. 
} 11.0 text {
} 12.0 text {"_###_##_#_#_#_#__#_____"  string now      
} 13.0 text {? Non-space control chars in source after: now
} 14.0 text {
} 15.0 text { 
} 16.0 text {damit getan. } 17.0

Der alte Fehler "Can't read range: no such variable".
Es können nicht-space Zeichen im Leerraum sein. 
- nicht nach space suchen sondern nacht non-printable chars.

regexp -indices -start $comp(i)  {\S+} $comp(text) range

\S+ sucht den folgenden Leerraum (space, tab, cr)

Testsource momentane Array Definition, aus EN kopiert: hat im Leerraum etwas das man nicht sieht, das aber auch kein \S+ ist.

E1: regexp = 0  setzt error "not found"  mit letztem erfassten Wort im source. 

"_###_##_#_#_#_#__#_____"  string now      
? Non-space control chars in source after: now

 
damit getan.




  0.574 TclForth mit externem Source 

mark insert 1.0 text {- do loop Indizes auch i,j,k Kleinschrift 
} 1.0 text {- ConsoleWindows 0.7.0 
} 2.0 text {- starten ohne CodeWindow
} 3.0 mark tk::anchor.work.page.panes.t.text 4.0 text {- TclForthStart ohne Verzeichniswechsel - wir sind schon bei Source } 4.0

- do loop Indizes auch i,j,k Kleinschrift 
- ConsoleWindows 0.7.0 
- starten ohne CodeWindow
- TclForthStart ohne Verzeichniswechsel - wir sind schon bei Source



